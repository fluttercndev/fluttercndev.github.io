(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{71:function(t,e,r){"use strict";r.r(e),r.d(e,"frontMatter",function(){return o}),r.d(e,"rightToc",function(){return l}),r.d(e,"default",function(){return f});r(0);var n=r(97);function a(){return(a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t}).apply(this,arguments)}function u(t,e){if(null==t)return{};var r,n,a=function(t,e){if(null==t)return{};var r,n,a={},u=Object.keys(t);for(n=0;n<u.length;n++)r=u[n],e.indexOf(r)>=0||(a[r]=t[r]);return a}(t,e);if(Object.getOwnPropertySymbols){var u=Object.getOwnPropertySymbols(t);for(n=0;n<u.length;n++)r=u[n],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(a[r]=t[r])}return a}var o={title:"Flutter的布局和绘制",author:"handoing",authorTitle:"A flutter fans",authorURL:"https://github.com/handoing",authorImageURL:"https://p5.ssl.qhimg.com/t01b6580ec3d65d7b7f.png",tags:["flutter","widget"]},l=[{value:"Flutter的布局和绘制",id:"flutter的布局和绘制",children:[]}],c={rightToc:l},i="wrapper";function f(t){var e=t.components,r=u(t,["components"]);return Object(n.b)(i,a({},c,r,{components:e,mdxType:"MDXLayout"}),Object(n.b)("h2",null,Object(n.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"flutter的布局和绘制"})),Object(n.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#flutter的布局和绘制"}),"#"),"Flutter的布局和绘制"),Object(n.b)("p",null,"本次主要讲解flutter如何实现布局和绘制，默认大家已学习过",Object(n.b)("a",a({parentName:"p"},{href:"https://www.fluttercn.dev/blog/2019/08/11/flutter-render"}),"《Flutter从加载到显示》")),Object(n.b)("p",null,"当flutter接收到系统发送来的Vsync信号时，会连续执行动画、构建、布局、绘制一系列操作，最后输出Sence（layer tree）并传递给flutter engine进行后续操作，其中绿色部分是本次要讲的内容，这里说明一下，在flutter里，layout和paint阶段操作的是RenderObject tree。"))}f.isMDXComponent=!0}}]);