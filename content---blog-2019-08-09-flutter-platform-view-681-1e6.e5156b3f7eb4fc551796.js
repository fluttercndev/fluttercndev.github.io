(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{43:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return o}),t.d(n,"rightToc",function(){return l}),t.d(n,"default",function(){return s});t(0);var i=t(90);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e}).apply(this,arguments)}function a(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o={title:"Flutter Platform View 使用及原理简析",author:"loosaSH",authorTitle:"A flutter fans",authorURL:"https://github.com/loosaSH",authorImageURL:"https://p5.ssl.qhimg.com/t01b6580ec3d65d7b7f.png",tags:["flutter","platform-view"]},l=[{value:"什么是 platform view？",id:"什么是-platform-view？",children:[]},{value:"简单使用",id:"简单使用",children:[{value:"Flutter 侧",id:"flutter-侧",children:[]},{value:"iOS 侧",id:"ios-侧",children:[]},{value:"Android 侧",id:"android-侧",children:[]},{value:"Flutter项目中的使用",id:"flutter项目中的使用",children:[]}]},{value:"发现问题",id:"发现问题",children:[]},{value:"源码分析",id:"源码分析",children:[]},{value:"如何开发一个 platform view",id:"如何开发一个-platform-view",children:[]}],d={rightToc:l},c="wrapper";function s(e){var n=e.components,t=a(e,["components"]);return Object(i.b)(c,r({},d,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h2",null,Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"什么是-platform-view？"})),Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#什么是-platform-view？"}),"#"),"什么是 platform view？"),Object(i.b)("p",null,"由于 Flutter 诞生于 Android 、iOS 非常成熟的时代背景，为了能让一些现有的 native 控件直接引用到 Flutter app 中，Flutter 团队提供了 AndroidView 、UIKitView 两个 widget 来满足需求，比如说 Flutter 中的 Webview、MapView，暂时无需使用 Flutter 重新开发一套。"),Object(i.b)("p",null,"其实 platform view 就是 AndroidView 和 UIKitView 的总称，允许将 native view 嵌入到了 flutter widget 体系中，完成 Datr 代码对 native view 的控制。"),Object(i.b)("h2",null,Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"简单使用"})),Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#简单使用"}),"#"),"简单使用"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"此处仅是简单使用，有很多不合理的代码，目的仅是让初学者能完成展示，后面会有具体的 framework 代码分析，及官方维护的 platform view 的分析。")),Object(i.b)("p",null,"先看一下效果吧"),Object(i.b)("p",null,Object(i.b)("img",r({parentName:"p"},{src:"http://p0.qhimg.com/t013d5e6465486ce0e6.png",alt:null}))),Object(i.b)("p",null,Object(i.b)("img",r({parentName:"p"},{src:"http://p0.qhimg.com/t012a61a67eb82cab12.png",alt:null}))),Object(i.b)("p",null,"存在与 native 交互的代码，建议用一个 plugin 来实现内部逻辑。"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Plugin: exposing an Android or iOS API for developers")),Object(i.b)("h3",null,Object(i.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"flutter-侧"})),Object(i.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#flutter-侧"}),"#"),"Flutter 侧"),Object(i.b)("p",null,"创建 Flutter plugin （建议使用 Android Studio），如果使用命令行，可以执行如下命令："),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-bash"}),"flutter create --org net.loosash --template = plugin share_platform_plugin\n")),Object(i.b)("p",null,"接下来在我们的插件工程里创建一个 widget 用来包裹 platform view。便于使用"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-dart"}),'import \'package:flutter/cupertino.dart\';\nimport \'package:flutter/foundation.dart\';\nimport \'package:flutter/services.dart\';\n\n/// 这里使用了 statelessWidget\nclass PlatformTextWidget extends StatelessWidget {\n  PlatformTextWidget({this.text});\n\n  final String text;\n\n  @override\n  Widget build(BuildContext context) {\n    // 根据运行平台判断执行代码\n    if (defaultTargetPlatform == TargetPlatform.android) {\n      return AndroidView(\n        // 在 native 中的唯一标识符，需要与 native 侧的值相同\n        viewType: "platform_text_view",\n        // 在创建 AndroidView 的同时，可以传递参数\n        creationParams: <String, dynamic>{"text": text},\n        // 用来编码 creationParams 的形式，可选 [StandardMessageCodec], [JSONMessageCodec], [StringCodec], or [BinaryCodec]\n        // 如果存在 creationParams，则该值不能为null\n        creationParamsCodec: const StandardMessageCodec(),\n      );\n    } else if (defaultTargetPlatform == TargetPlatform.iOS) {\n      return UiKitView(\n        viewType: "platform_text_view",\n        creationParams: <String, dynamic>{"text": text},\n        creationParamsCodec: const StandardMessageCodec(),\n      );\n    } else {\n      return Text("不支持的平台");\n    }\n  }\n}\n')),Object(i.b)("h3",null,Object(i.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"ios-侧"})),Object(i.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#ios-侧"}),"#"),"iOS 侧"),Object(i.b)("p",null,"在编辑Xcode中的iOS平台代码之前，首先确保代码至少已构建过一次。在创建的 plugin/example 目录下执行 build，如下："),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-bash"}),"cd share_platform_plugin/example\nflutter build ios --no-codesign\n或者执行 pod install\n")),Object(i.b)("p",null,"然后使用 Xcode 打开 share_platform_plugin/example/ios/Runner.xcworkspace，plugin 相关的代码目录很深，在 Pods/Development Pods/share_platform_plugin 内部，具体找到 SharePlatformPlugin.h 与 SharePlatformPlugin.m 目录即位我们操作的目录。"),Object(i.b)("p",null,"接下来我们先创建需要展示的 View ，这里仅以一个 UILabel 为例。"),Object(i.b)("p",null,"IOSTextView.h"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-objective-c"}),"#import <Foundation/Foundation.h>\n#import <Flutter/Flutter.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface IOSTextView : NSObject<FlutterPlatformView>\n\n- (instancetype)initWithFrame:(CGRect)frame\n                   viewIdentifier:(int64_t)viewId\n                        arguments:(id _Nullable)args\n                  binaryMessenger:(NSObject<FlutterBinaryMessenger>*)messenger;\n@end\n\nNS_ASSUME_NONNULL_END\n")),Object(i.b)("p",null,"IOSTextView.m"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-objective-c"}),'#import <Foundation/Foundation.h>\n#import "IOSTextView.h"\n\n@implementation IOSTextView{\n    int64_t _viewId;\n    FlutterMethodChannel* _channel;\n    UILabel * _uiLabel;\n}\n\n\n- (instancetype)initWithFrame:(CGRect)frame viewIdentifier:(int64_t)viewId arguments:(id)args binaryMessenger:(NSObject<FlutterBinaryMessenger> *)messenger{\n    \n    NSString *text = @"iOS端UILabel";\n\n    if ([args isKindOfClass:[NSDictionary class]]) {\n        NSDictionary *params = (NSDictionary *)args;\n        if([[params allKeys] containsObject:@"text"]){\n            if ([[params valueForKey:@"text"] isKindOfClass:[NSString class]]) {\n                text= [params valueForKey:@"text"];\n            }\n        }\n    }\n    _uiLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];\n    _uiLabel.textAlignment = NSTextAlignmentCenter;\n    _uiLabel.text = text;\n    _uiLabel.font = [UIFont systemFontOfSize:30];\n    return self;\n}\n\n-(UIView *)view{\n    return _uiLabel;\n}\n\n@end\n')),Object(i.b)("p",null,"然后创建 FlutterPlatformViewFactory"),Object(i.b)("p",null,"SharePlatformViewFactory.h"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-objective-c"}),"#import <Foundation/Foundation.h>\n#import <Flutter/Flutter.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface SharePlatformViewFactory : NSObject<FlutterPlatformViewFactory>\n\n- (instancetype)initWithMessenger:(NSObject<FlutterBinaryMessenger>*)messager;\n\n-(NSObject<FlutterMessageCodec> *)createArgsCodec;\n\n-(NSObject<FlutterPlatformView> *)createWithFrame:(CGRect)frame viewIdentifier:(int64_t)viewId arguments:(id)args;\n\n@end\nNS_ASSUME_NONNULL_END\n")),Object(i.b)("p",null,"SharePlatformViewFactory.m"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-objective-c"}),'#import "SharePlatformViewFactory.h"\n#import "IOSTextView.h"\n\n@implementation SharePlatformViewFactory{\n    NSObject<FlutterBinaryMessenger>*_messenger;\n}\n\n- (instancetype)initWithMessenger:(NSObject<FlutterBinaryMessenger> *)messager{\n    self = [super init];\n    if (self) {\n        _messenger = messager;\n    }\n    return self;\n}\n\n-(NSObject<FlutterMessageCodec> *)createArgsCodec{\n    return [FlutterStandardMessageCodec sharedInstance];\n}\n\n-(NSObject<FlutterPlatformView> *)createWithFrame:(CGRect)frame viewIdentifier:(int64_t)viewId arguments:(id)args{\n    IOSTextView *iosTextView = [[IOSTextView alloc] initWithFrame:frame viewIdentifier:viewId arguments:args binaryMessenger:_messenger];\n    return iosTextView;\n}\n\n@end\n')),Object(i.b)("p",null,"接下来在 SharePlatformPlugin.m 中添加我们创建 SharePlatformViewFactory 的注册。"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-objective-c"}),'#import "SharePlatformPlugin.h"\n#import "SharePlatformViewFactory.h"\n\n@implementation SharePlatformPlugin\n+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar>*)registrar {\n  FlutterMethodChannel* channel = [FlutterMethodChannel\n      methodChannelWithName:@"share_platform_plugin"\n            binaryMessenger:[registrar messenger]];\n  SharePlatformPlugin* instance = [[SharePlatformPlugin alloc] init];\n  [registrar addMethodCallDelegate:instance channel:channel];\n    // 添加注册我们创建的 view ，注意这里的 withId 需要和 flutter 侧的值相同\n    [registrar registerViewFactory:[[SharePlatformViewFactory alloc] initWithMessenger:registrar.messenger] withId:@"platform_text_view"];\n\n}\n\n- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result {\n  if ([@"getPlatformVersion" isEqualToString:call.method]) {\n    result([@"iOS " stringByAppendingString:[[UIDevice currentDevice] systemVersion]]);\n  } else {\n    result(FlutterMethodNotImplemented);\n  }\n}\n\n@end\n')),Object(i.b)("p",null,"最后，还需要在 Flutter 项目中的 ios/Runner/info.plist 中增加，就是运行 flutter 的项目"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{}),"    <key>io.flutter.embedded_views_preview</key>\n    <true/>\n")),Object(i.b)("p",null,"iOS侧就完成了。"),Object(i.b)("h3",null,Object(i.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"android-侧"})),Object(i.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#android-侧"}),"#"),"Android 侧"),Object(i.b)("p",null,"直接使用 Android Studio 打开 plugin 中的 android 目录，share_platform_plugin/android"),Object(i.b)("p",null,"接下来我们先创建需要展示的 View ，这里仅以一个 TextView 为例。"),Object(i.b)("p",null,"AndroidTextView.kt"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-kotlin"}),'class AndroidTextView(context: Context,\n                      messenger: BinaryMessenger,\n                      id: Int?,\n                      params: Map<String, Any>?) : PlatformView {\n    private val mAndroidTextView: TextView = TextView(context)\n    init {\n        val text = params?.get("text") as CharSequence?\n\n        mAndroidTextView.text = if (text == null) {\n            text\n        } else {\n            "android端TextView"\n        }\n        \n        mAndroidTextView.textSize = 30f\n    }\n    override fun getView(): View = mAndroidTextView\n    override fun dispose() {}\n}\n')),Object(i.b)("p",null,"创建 SharePlatformViewFactory.kt"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-kotlin"}),"class SharePlatformViewFactory(private val messenger: BinaryMessenger)\n    : PlatformViewFactory(StandardMessageCodec.INSTANCE) {\n    \n    override fun create(context: Context, id: Int, args: Any?): PlatformView {\n        val params = args?.let { args as Map<String, Any> }\n        return AndroidTextView(context, messenger, id, params)\n\n    }\n}\n")),Object(i.b)("p",null,"最后，在 SharePlatformPlugin 中添加我们创建 SharePlatformViewFactory 的注册。"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-kotlin"}),'class SharePlatformPlugin: MethodCallHandler {\n  companion object {\n    @JvmStatic\n    fun registerWith(registrar: Registrar) {\n      val channel = MethodChannel(registrar.messenger(), "share_platform_plugin")\n      channel.setMethodCallHandler(SharePlatformPlugin())\n      // 添加注册我们创建的 view ，注意这里的 withId 需要和 flutter 侧的值相同\n      registrar.platformViewRegistry().registerViewFactory("platform_text_view", SharePlatformViewFactory(registrar.messenger()))\n    }\n  }\n\n  override fun onMethodCall(call: MethodCall, result: Result) {\n    if (call.method == "getPlatformVersion") {\n      result.success("Android ${android.os.Build.VERSION.RELEASE}")\n    } else {\n      result.notImplemented()\n    }\n  }\n}\n')),Object(i.b)("p",null,"这样 Andorid 侧的代码就完成了。"),Object(i.b)("h3",null,Object(i.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"flutter项目中的使用"})),Object(i.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#flutter项目中的使用"}),"#"),"Flutter项目中的使用"),Object(i.b)("p",null,"在 Flutter 工程中 pubspec.yaml 引入该 plugin 。"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-yaml"}),"dependencies:\n  flutter:\n    sdk: flutter\n\n  cupertino_icons: ^0.1.2\n  # 下面是对我们新建插件的依赖\n  share_platform_plugin:\n    path: ../share_platform_plugin\n")),Object(i.b)("p",null,"执行 Packages get"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-bash"}),"flutter package get\n")),Object(i.b)("p",null,"在需要展示的地方和正常的 widget 一样使用我们自己创建的 PlatformTextWidget"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-dart"}),"import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:share_platform_plugin/widget/platform_text_widget.dart';\n\nclass TextPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"native text\"),\n      ),\n      body: SafeArea(\n        child: Column(\n          children: <Widget>[\n            Text(\"这里是flutter的Text\"),\n            Expanded(\n              child: PlatformTextWidget(text:\"123\"),\n            ),\n            Text(\"这里是flutter的Text\"),\n          ],\n        ),\n      ),\n    );\n  }\n}\n")),Object(i.b)("h2",null,Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"发现问题"})),Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#发现问题"}),"#"),"发现问题"),Object(i.b)("p",null,"如果上面的代码你自己写一遍，你就会发现存在很多的问题。"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"id 在对应的端上没有被使用，可以用来做什么？"),Object(i.b)("li",{parentName:"ol"},"这里的 PlatformTextWidget 被 Expanded 包裹着，如果不包裹就会出现超出边界的错误，那么这个 Widget 的大小是怎么控制的呢？"),Object(i.b)("li",{parentName:"ol"},"platform view 的绘制是在 native 侧完成的还是在 flutter 侧完成的呢？")),Object(i.b)("p",null,"带着问题，我们看一遍源码，看看是否能找到相关的答案。"),Object(i.b)("h2",null,Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"源码分析"})),Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#源码分析"}),"#"),"源码分析"),Object(i.b)("p",null,"先来看看 AndroidView 吧"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-dart"}),"// 继承了 StatefulWidget\nclass AndroidView extends StatefulWidget {\n  const AndroidView({\n    Key key,\n    @required this.viewType,\n    this.onPlatformViewCreated,\n    this.hitTestBehavior = PlatformViewHitTestBehavior.opaque,\n    this.layoutDirection,\n    this.gestureRecognizers,\n    this.creationParams,\n    this.creationParamsCodec,\n  }) : assert(viewType != null),\n       assert(hitTestBehavior != null),\n       assert(creationParams == null || creationParamsCodec != null),\n       super(key: key);\n\n  /// 嵌入Android视图类型的唯一标识符 \n  final String viewType;\n\n  /// platform view 创建完成的回调\n  final PlatformViewCreatedCallback onPlatformViewCreated;\n\n    /// hit测试期间的行为\n  final PlatformViewHitTestBehavior hitTestBehavior;\n\n  /// 视图的文本方向\n  final TextDirection layoutDirection;\n  \n  /// 用于处理事件冲突，对事件进行分发管理相关操作\n  final Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers;\n\n  /// 传给 Android 视图的参数，在 Android 视图构造的时候使用\n  final dynamic creationParams;\n\n  /// 对 creationParams 参数传递时进行的编码规则，如果 creationParams 不为 null，该值必须不为 null\n  final MessageCodec<dynamic> creationParamsCodec;\n\n  @override\n  State<AndroidView> createState() => _AndroidViewState();\n}\n")),Object(i.b)("p",null,"有一些需要注意的点"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"AndroidView 仅支持 Android API 20 及以上；"),Object(i.b)("li",{parentName:"ul"},"在Flutter 中使用 AndroidView 对性能的开销比较大，应该尽可能的避免使用；"),Object(i.b)("li",{parentName:"ul"},"可以把它当作一个 Flutter 的 wedget 一样的使用。")),Object(i.b)("p",null,"接下来我们看一下这个 State 对象，关于生命周期的知识，这里给出链接："),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-dart"}),"class _AndroidViewState extends State<AndroidView> {\n  // 用于区分不同的 View 来接收不同的操作指令，可以说不同的 id 代表着不同的 view\n  // 在_createNewAndroidView方法中被赋值\n  // 触发条件：1、在 didChangeDependencies 生命周期中第一次初始化触发\n  // 2、didUpdateWidget 生命周期中 传入的viewType 发生改变时触发\n  int _id;\n  // AndroidView的控制器，和 _id 的赋值场景相同\n  AndroidViewController _controller;\n  // 布局方向，widget 传入\n  TextDirection _layoutDirection;\n  // 被初始化的标识，保证_createNewAndroidView()操作以及_focusNode被操作一次\n  bool _initialized = false;\n  // 获取键盘焦点及事件的相关类\n  FocusNode _focusNode;\n  // 创建一个空的set集合，如果没有传入gestureRecognizers，则使用该空集合\n  static final Set<Factory<OneSequenceGestureRecognizer>> _emptyRecognizersSet =\n    <Factory<OneSequenceGestureRecognizer>>{};\n\n  // build 方法，包裹了一层 Focus 用来处理焦点的问题，内部真实使用的是 _AndroidPlatformView，后面单独分析_AndroidPlatformView\n  @override\n  Widget build(BuildContext context) {\n    return Focus(\n      focusNode: _focusNode,\n      onFocusChange: _onFocusChange,\n      child: _AndroidPlatformView(\n        controller: _controller,\n        hitTestBehavior: widget.hitTestBehavior,\n        gestureRecognizers: widget.gestureRecognizers ?? _emptyRecognizersSet,\n      ),\n    );\n  }\n\n  // 保证操作仅执行一次\n  void _initializeOnce() {\n    if (_initialized) {\n      return;\n    }\n    _initialized = true;\n    _createNewAndroidView();\n    _focusNode = FocusNode(debugLabel: 'AndroidView(id: $_id)');\n  }\n\n  // didChangeDependencies 生命周期回调\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    final TextDirection newLayoutDirection = _findLayoutDirection();\n    // 布局方向调教，是否有改变\n    final bool didChangeLayoutDirection = _layoutDirection != newLayoutDirection;\n    _layoutDirection = newLayoutDirection;\n    \n        // 会多次回调该生命周期，但是保证关键操作仅执行一次\n    _initializeOnce();\n    // 根据条件判断是否需要重制布局方向\n    if (didChangeLayoutDirection) {\n      _controller.setLayoutDirection(_layoutDirection);\n    }\n  }\n\n  // didUpdateWidget 生命周期回调\n  @override\n  void didUpdateWidget(AndroidView oldWidget) {\n    super.didUpdateWidget(oldWidget);\n\n    final TextDirection newLayoutDirection = _findLayoutDirection();\n    final bool didChangeLayoutDirection = _layoutDirection != newLayoutDirection;\n    _layoutDirection = newLayoutDirection;\n\n    // 根据viewType是否相同来确定是否需要重新创建 AndroidView，生成新的id\n    if (widget.viewType != oldWidget.viewType) {\n      _controller.dispose();\n      _createNewAndroidView();\n      return;\n    }\n\n    // 布局方向相关\n    if (didChangeLayoutDirection) {\n      _controller.setLayoutDirection(_layoutDirection);\n    }\n  }\n\n  TextDirection _findLayoutDirection() {\n    assert(widget.layoutDirection != null || debugCheckHasDirectionality(context));\n    return widget.layoutDirection ?? Directionality.of(context);\n  }\n\n  // 回收资源\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  // 关键的方法，生成 _id 及 _controller,用于传递给_AndroidPlatformView\n  void _createNewAndroidView() {\n    // 每次对 _id 进行自增，保证唯一性。\n    _id = platformViewsRegistry.getNextPlatformViewId();\n    // initAndroidView 构造了一个 _controller，将参数端都交给 _controller 保管\n    _controller = PlatformViewsService.initAndroidView(\n      id: _id,\n      viewType: widget.viewType,\n      layoutDirection: _layoutDirection,\n      creationParams: widget.creationParams,\n      creationParamsCodec: widget.creationParamsCodec,\n      onFocus: () {\n        _focusNode.requestFocus();\n      }\n    );\n    // 添加回调，给开发者使用\n    if (widget.onPlatformViewCreated != null) {\n      _controller.addOnPlatformViewCreatedListener(widget.onPlatformViewCreated);\n    }\n  }\n\n  // 焦点变更\n  void _onFocusChange(bool isFocused) {\n    if (!_controller.isCreated) {\n      return;\n    }\n    if (!isFocused) {\n      _controller.clearFocus().catchError((dynamic e) {\n       if (e is MissingPluginException) {\n         return;\n       }\n      });\n      return;\n    }\n    // 通过 flutter engin 来实实现焦点变更对 native view 的处理\n    SystemChannels.textInput.invokeMethod<void>(\n      'TextInput.setPlatformViewClient',\n      _id,\n    ).catchError((dynamic e) {\n      if (e is MissingPluginException) {\n        return;\n      }\n    });\n  }\n}\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"小结一下"),"："),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"我们解决解决了如下问题"),"："),Object(i.b)("p",null,"这里我们发现了 id 的作用，当创建的时候，分配一个 id，在 viewType 改变的时候从新分配，其实就是对应 native 侧创建 view 的时候，所以可以通过 id 来保证通过 channel 来和不同 view 进行通信，解决 view 的区分处理。"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"我们又遇到了新的问题"),"："),Object(i.b)("p",null,"AndroidViewController、_AndroidPlatformView都做了什么？"),Object(i.b)("p",null,"我们先来分析一下 AndroidViewController 会对我们上面的问题和 _AndroidPlatformView 的分析有帮助。"),Object(i.b)("p",null,"这里会有 Texture 纹理相关的知识，这里不做分析，有兴趣可以查看一下相关文章"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-dart"}),"// AndroidViewController 是通过 PlatformViewsService.initAndroidView 方法创建的，上面有的分析过程里有\nclass AndroidViewController {\n  AndroidViewController._(\n    this.id,\n    String viewType,\n    dynamic creationParams,\n    MessageCodec<dynamic> creationParamsCodec,\n    TextDirection layoutDirection,\n  ) : assert(id != null),\n      assert(viewType != null),\n      assert(layoutDirection != null),\n      assert(creationParams == null || creationParamsCodec != null),\n      _viewType = viewType,\n      _creationParams = creationParams,\n      _creationParamsCodec = creationParamsCodec,\n      _layoutDirection = layoutDirection,\n      _state = _AndroidViewState.waitingForSize;\n\n\n  // 对应了很多 android 中的点击事件 MotionEvent 相关\n  // [MotionEvent.ACTION_DOWN]\n  static const int kActionDown =  0;\n    // [MotionEvent.ACTION_UP]\n  static const int kActionUp =  1;\n  // [MotionEvent.ACTION_MOVE]\n  static const int kActionMove = 2;\n  // [MotionEvent.ACTION_CANCEL]\n  static const int kActionCancel = 3;\n  // [MotionEvent.ACTION_POINTER_DOWN]\n  static const int kActionPointerDown =  5;\n  // [MotionEvent.ACTION_POINTER_UP]\n  static const int kActionPointerUp =  6;\n  // 布局方向相关\n  // [View.LAYOUT_DIRECTION_LTR]\n  static const int kAndroidLayoutDirectionLtr = 0;\n  // [View.LAYOUT_DIRECTION_RTL]\n  static const int kAndroidLayoutDirectionRtl = 1;\n\n  // 标识 id 上面已经分析过了\n  final int id;\n\n  // native 侧注册的 viewType 字段\n  final String _viewType;\n\n  // 在创建 andorid 端 view 的时候（下文 _create方法），返回_textureId。\n  // 该 id 是在 native 侧渲染完成后绘图数据对应的id，可以直接在GPU中找到并直接使用\n  // Flutter 的 Framework 层最后会递交给 Engine 层一个 layerTree ，包含了此处的 _textureId，最终在绘制的时候，skia 会直接在 GPU 中根据 textureId 找到相应的绘制数据，并将其绘制到屏幕上。\n  int _textureId;\n  // _textureId 的 get 方法\n  int get textureId => _textureId;\n\n  TextDirection _layoutDirection;\n\n  // 枚举状态\n  _AndroidViewState _state;\n\n  // 参数\n  dynamic _creationParams;\n\n  // 编码类\n  MessageCodec<dynamic> _creationParamsCodec;\n\n  // 回调集合\n  final List<PlatformViewCreatedCallback> _platformViewCreatedCallbacks = <PlatformViewCreatedCallback>[];\n\n  /// 获取 view 的 create 状态\n  bool get isCreated => _state == _AndroidViewState.created;\n\n  void addOnPlatformViewCreatedListener(PlatformViewCreatedCallback listener) {\n    assert(listener != null);\n    assert(_state != _AndroidViewState.disposed);\n    _platformViewCreatedCallbacks.add(listener);\n  }\n\n  void removeOnPlatformViewCreatedListener(PlatformViewCreatedCallback listener) {\n    assert(_state != _AndroidViewState.disposed);\n    _platformViewCreatedCallbacks.remove(listener);\n  }\n\n  // Disposes the Android view.\n  // 通过 engine 调用了 native 的 dispose 方法、清空回调集合、disposed 当前 widget 的 state\n  Future<void> dispose() async {\n    if (_state == _AndroidViewState.creating || _state == _AndroidViewState.created)\n      await SystemChannels.platform_views.invokeMethod<void>('dispose', id);\n    _platformViewCreatedCallbacks.clear();\n    _state = _AndroidViewState.disposed;\n  }\n\n  // 设置 Android View 的大小，通过 engine 调用了 native 的 resize 方法\n  Future<void> setSize(Size size) async {\n    assert(_state != _AndroidViewState.disposed, 'trying to size a disposed Android View. View id: $id');\n\n    assert(size != null);\n    assert(!size.isEmpty);\n\n    if (_state == _AndroidViewState.waitingForSize)\n      return _create(size);\n\n    await SystemChannels.platform_views.invokeMethod<void>('resize', <String, dynamic>{\n      'id': id,\n      'width': size.width,\n      'height': size.height,\n    });\n  }\n\n  // 通过 engine 调用了 native 的 setDirection 方法，设置 Android view 方向\n  Future<void> setLayoutDirection(TextDirection layoutDirection) async {\n    assert(_state != _AndroidViewState.disposed,'trying to set a layout direction for a disposed UIView. View id: $id');\n\n    if (layoutDirection == _layoutDirection)\n      return;\n\n    assert(layoutDirection != null);\n    _layoutDirection = layoutDirection;\n\n    if (_state == _AndroidViewState.waitingForSize)\n      return;\n\n    await SystemChannels.platform_views.invokeMethod<void>('setDirection', <String, dynamic>{\n      'id': id,\n      'direction': _getAndroidDirection(layoutDirection),\n    });\n  }\n\n  // 通过 engine 调用了 native 的 clearFocus 方法，清除焦点\n  Future<void> clearFocus() {\n    if (_state != _AndroidViewState.created) {\n      return null;\n    }\n    return SystemChannels.platform_views.invokeMethod<void>('clearFocus', id);\n  }\n\n  // 获得布局方向\n  static int _getAndroidDirection(TextDirection direction) {\n    assert(direction != null);\n    switch (direction) {\n      case TextDirection.ltr:\n        return kAndroidLayoutDirectionLtr;\n      case TextDirection.rtl:\n        return kAndroidLayoutDirectionRtl;\n    }\n    return null;\n  }\n\n  // 通过 engine 调用 native 的 touch 方法，将事件发送给 android view 处理\n  Future<void> sendMotionEvent(AndroidMotionEvent event) async {\n    await SystemChannels.platform_views.invokeMethod<dynamic>(\n        'touch',\n        event._asList(id),\n    );\n  }\n\n  /// Creates a masked Android MotionEvent action value for an indexed pointer.\n  static int pointerAction(int pointerId, int action) {\n    return ((pointerId << 8) & 0xff00) | (action & 0xff);\n  }\n\n  // 真正创建 view 的方法，也是通过 engine 调用 native 的 create 方法，传入了 width 和 height\n  Future<void> _create(Size size) async {\n    final Map<String, dynamic> args = <String, dynamic>{\n      'id': id,\n      'viewType': _viewType,\n      'width': size.width,\n      'height': size.height,\n      'direction': _getAndroidDirection(_layoutDirection),\n    };\n    if (_creationParams != null) {\n      final ByteData paramsByteData = _creationParamsCodec.encodeMessage(_creationParams);\n      args['params'] = Uint8List.view(\n        paramsByteData.buffer,\n        0,\n        paramsByteData.lengthInBytes,\n      );\n    }\n    _textureId = await SystemChannels.platform_views.invokeMethod('create', args);\n    _state = _AndroidViewState.created;\n    for (PlatformViewCreatedCallback callback in _platformViewCreatedCallbacks) {\n      // 遍历、回调\n      callback(id);\n    }\n  }\n}\n")),Object(i.b)("p",null,"我们看到了 view 的大小由 _create 方法传入，那传入的值是怎么获得的呢？我们先把还没分析的 _AndroidPlatformView 看完再下结论。"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-dart"}),"class _AndroidPlatformView extends LeafRenderObjectWidget {\n  // 将 controller 传进来了，具体没做太多的操作，主要还是通过 controller 来实现的。\n  const _AndroidPlatformView({\n    Key key,\n    @required this.controller,\n    @required this.hitTestBehavior,\n    @required this.gestureRecognizers,\n  }) : assert(controller != null),\n       assert(hitTestBehavior != null),\n       assert(gestureRecognizers != null),\n       super(key: key);\n\n  final AndroidViewController controller;\n  final PlatformViewHitTestBehavior hitTestBehavior;\n  final Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers;\n\n  // 需要注意的是这两个方法，这里重写了 createRenderObject 方法。\n  @override\n  RenderObject createRenderObject(BuildContext context) =>\n      RenderAndroidView(\n        viewController: controller,\n        hitTestBehavior: hitTestBehavior,\n        gestureRecognizers: gestureRecognizers,\n      );\n\n  @override\n  void updateRenderObject(BuildContext context, RenderAndroidView renderObject) {\n    renderObject.viewController = controller;\n    renderObject.hitTestBehavior = hitTestBehavior;\n    renderObject.updateGestureRecognizers(gestureRecognizers);\n  }\n}\n")),Object(i.b)("p",null,"我这里先假设大家都知道 Widget、Element、RenderObject之间的关系，如果不是很清晰，这篇文章里有详细的介绍。"),Object(i.b)("p",null,"RenderObject 的最终大小的确定有两种情况，一个是由父节点所指定，一个是根据自己的情况确定。默认的 RenderObject 中有一个 sizedByParent 属性，默认为 false，即根据自身大小确定。这里指定了 RenderObject 为 RenderAndroidView ，我们来看一下这个类，这里就不一行一行的分析了，我们把重点提出来。"),Object(i.b)("pre",null,Object(i.b)("code",r({parentName:"pre"},{className:"language-dart"}),"  @override\n  bool get sizedByParent => true;\n")),Object(i.b)("p",null,"所以我们可以得出结论了。"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"再小结一下"),"："),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"我们解决解决了剩下的问题"),"："),Object(i.b)("p",null,"1、我们了解了 AndroidViewController、_AndroidPlatformView 都做了什么。"),Object(i.b)("p",null,"2、AndroidView 的大小是由父节点的大小去定的所以上面使用 Expanded 包裹则可以生效，如果不进行包裹，则大小为父控件大小，在 Column 中会出现问题。当 Widget size 小于 View size，Flutter 会进行裁剪。当 Widget  size 大于 View size 时，多出来的位置会被背景填充。在 Android 侧，实现了 PlatformView 的 View 会被包裹在 FrameLayout 中，可以对 View 的绘制添加监听，打印出 View 的 parent；"),Object(i.b)("p",null,"3、platform view 是在 native 侧渲染的，返回给 Flutter 侧一个 _textureId ，通过这个 id Flutter 将 View 直接展示出来。这部分也说明了为什么 platform view 在 Flutter 中的性能开销比较大，整个过程数据需要从 GPU -> CPU -> GPU，这部分的代价是比较大的。"),Object(i.b)("h2",null,Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"如何开发一个-platform-view"})),Object(i.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#如何开发一个-platform-view"}),"#"),"如何开发一个 platform view"),Object(i.b)("p",null,"其实 Flutter 官方维护了一些 plugin，链接如下："),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"}," ",Object(i.b)("a",r({parentName:"p"},{href:"https://github.com/flutter/plugins"}),"https://github.com/flutter/plugins"))),Object(i.b)("p",null,"其中的 ",Object(i.b)("a",r({parentName:"p"},{href:"https://github.com/flutter/plugins/blob/master/packages/webview_flutter"}),"webview_flutter")," 、",Object(i.b)("a",r({parentName:"p"},{href:"https://github.com/flutter/plugins/blob/master/packages/google_maps_flutter"}),"google_maps_flutter")," 就是通过 platform view，就是一个很好的 demo 。"),Object(i.b)("p",null,"参考资料："),Object(i.b)("p",null,"在Flutter中嵌入Native组件的正确姿势",Object(i.b)("a",r({parentName:"p"},{href:"https://yq.aliyun.com/articles/669831?utm_content=m_1000024586"}),"https://yq.aliyun.com/articles/669831?utm_content=m_1000024586")),Object(i.b)("p",null,"github:Flutter Plugin ",Object(i.b)("a",r({parentName:"p"},{href:"https://github.com/flutter/plugins"}),"https://github.com/flutter/plugins")),Object(i.b)("p",null,"Flutter 从加载到显示",Object(i.b)("a",r({parentName:"p"},{href:"https://mp.weixin.qq.com/s/ncViI0KGikPUIZ7BlEHGOA"}),"https://mp.weixin.qq.com/s/ncViI0KGikPUIZ7BlEHGOA")),Object(i.b)("p",null,"Flutter外接纹理",Object(i.b)("a",r({parentName:"p"},{href:"https://zhuanlan.zhihu.com/p/42566807"}),"https://zhuanlan.zhihu.com/p/42566807")),Object(i.b)("p",null,"Flutter State的生命周期",Object(i.b)("a",r({parentName:"p"},{href:"https://www.jianshu.com/p/f39cf2f7ad78"}),"https://www.jianshu.com/p/f39cf2f7ad78")))}s.isMDXComponent=!0}}]);