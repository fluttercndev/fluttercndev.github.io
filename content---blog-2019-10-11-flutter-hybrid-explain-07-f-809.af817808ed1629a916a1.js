(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{40:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return i}),n.d(t,"rightToc",function(){return u}),n.d(t,"default",function(){return o});n(0);var r=n(105);function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function a(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var i={title:"Flutter 混合栈复用原理",author:"loosaSH",authorTitle:"A flutter fans",authorURL:"https://github.com/loosaSH",authorImageURL:"https://p5.ssl.qhimg.com/t01b6580ec3d65d7b7f.png",tags:["flutter","hybrid"]},u=[{value:"一、什么是混合栈",id:"一、什么是混合栈",children:[]},{value:"二、为什么会产生问题",id:"二、为什么会产生问题",children:[{value:"目标是什么",id:"目标是什么",children:[]},{value:"Flutter 架构图",id:"flutter-架构图",children:[]},{value:"在 Android 中的 Flutter",id:"在-android-中的-flutter",children:[]},{value:"源码阅读",id:"源码阅读",children:[]},{value:"我们能做什么",id:"我们能做什么",children:[]}]},{value:"三、混合栈处理框架",id:"三、混合栈处理框架",children:[{value:"Flutter Boost 0.0.4+版本",id:"flutter-boost-004版本",children:[]},{value:"Flutter Boost 0.1.5+版本",id:"flutter-boost-015版本",children:[]}]},{value:"官方提供的方式",id:"官方提供的方式",children:[]},{value:"小结",id:"小结",children:[]}],c={rightToc:u},b="wrapper";function o(e){var t=e.components,n=a(e,["components"]);return Object(r.b)(b,l({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"本文将以 Android 视角，来扒一扒 Flutter 混合栈的前世今生。其实也就是从 1.0 正式发布到现在 1.9 版本的一些变更。"),Object(r.b)("p",null,"本文将会从以下几个方面来分析："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"什么是 Flutter 混合栈"),Object(r.b)("li",{parentName:"ul"},"为什么会产生问题"),Object(r.b)("li",{parentName:"ul"},"处理混合栈的相关框架"),Object(r.b)("li",{parentName:"ul"},"官方的处理方案")),Object(r.b)("h2",null,Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"一、什么是混合栈"})),Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#一、什么是混合栈"}),"#"),"一、什么是混合栈"),Object(r.b)("p",null,"一个新的技术的兴起，必然是一步一步向前的，Flutter 在成熟的 Android、iOS 的大环境下的生存，必要与 native 融合。"),Object(r.b)("p",null,"一些成熟的 APP ，如果想使用 Flutter 技术，必然不会完全使用 Flutter 重写，那样的成本太高，所以 Native + Flutter 的项目就出现了，Native 页面与 Flutter 页面共存，甚至交替呈现在用户手机上。"),Object(r.b)("p",null,"那什么是混合栈呢？"),Object(r.b)("p",null,"相信你已经有了答案，下面我们用 Android 的视角来重新审视一下混合栈。"),Object(r.b)("p",null,Object(r.b)("img",l({parentName:"p"},{src:"http://p0.qhimg.com/t0196b0247a89e11c1e.jpg",alt:null}))),Object(r.b)("p",null,"我们使用 flutter boost 框架提供的 demo 来看一下混合栈的效果（debug包）"),Object(r.b)("p",null,Object(r.b)("img",l({parentName:"p"},{src:"http://p0.qhimg.com/t01fa492e6dc759628b.gif",alt:null}))),Object(r.b)("h2",null,Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"二、为什么会产生问题"})),Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#二、为什么会产生问题"}),"#"),"二、为什么会产生问题"),Object(r.b)("p",null,"知道了混合栈问题，接下来我们要考虑为什么会出现这样的问题。"),Object(r.b)("h3",null,Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"目标是什么"})),Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#目标是什么"}),"#"),"目标是什么"),Object(r.b)("p",null,"现状是一个 Activity 中存在多个 Flutter Page，我们想要的是 Flutter Page 与 Android Activity 可以一一对应，这样便可以简单的将两个页面栈合并成一个栈，并且在性能上不会产生影响，这就是我们处理混合栈的目标。"),Object(r.b)("p",null,"如上图混合栈所示，Android 中以 FlutterView 承载 Flutter 的展示，默认情况下不同 FlutterView 创建了不同的 engine。如果一个 Flutter Page 对应一个 Activity， 这就导致了资源的多次重复创建和内存的不共享。"),Object(r.b)("p",null,"如果极端情况下，Native => Flutter => Native => … => Native => Flutter 会是什么情况呢？后果不堪设想，当然，可以从业务上避免这样的问题，但是作为框架的制定者，必须要考虑到这样的问题。"),Object(r.b)("p",null,"接下来我们看如何解决问题。需要从原理入手，需要阅读源码"),Object(r.b)("h3",null,Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"flutter-架构图"})),Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#flutter-架构图"}),"#"),"Flutter 架构图"),Object(r.b)("p",null,"从最经典的 Flutter 架构图入手"),Object(r.b)("p",null,Object(r.b)("img",l({parentName:"p"},{src:"https://raw.githubusercontent.com/flutter/engine/master/docs/flutter_overview.svg?sanitize=true",alt:"Flutter System Overview"}))),Object(r.b)("p",null,"从图中可以看到 3 层架构，每层提供了不同的能力"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Framework：这一层提供了Flutter 的常用控件，也提供了用于绘制的一些准备工作，详见",Object(r.b)("a",l({parentName:"li"},{href:"https://mp.weixin.qq.com/s/ncViI0KGikPUIZ7BlEHGOA"}),"Flutter 从加载到显示")),Object(r.b)("li",{parentName:"ul"},"Engine：这一层提供了Flutter的2D图形渲染库Skia和用于垃圾收集的面向对象语言的 Dart VM，并将它们托管在Shell中。这里也提供了 Platform Channels 等与 Native 交互的 API。可以参考这篇文章",Object(r.b)("a",l({parentName:"li"},{href:"https://github.com/flutter/flutter/wiki/The-Engine-architecture"}),"The Engine architecture")),Object(r.b)("li",{parentName:"ul"},"Embedder：这一层提供了不同平台的嵌入 API 如 Andorid、iOS。使得 Flutter 可以运行在不同的嵌入式平台。这里有一片关于自定义 Embedder 的文章",Object(r.b)("a",l({parentName:"li"},{href:"https://github.com/flutter/flutter/wiki/Custom-Flutter-Engine-Embedders"}),"Custom Flutter Engine Embedders"))),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Flutter 从加载到显示",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://mp.weixin.qq.com/s/ncViI0KGikPUIZ7BlEHGOA"}),"https://mp.weixin.qq.com/s/ncViI0KGikPUIZ7BlEHGOA")),Object(r.b)("p",{parentName:"blockquote"},"The Engine architecture",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://github.com/flutter/flutter/wiki/The-Engine-architecture"}),"https://github.com/flutter/flutter/wiki/The-Engine-architecture")),Object(r.b)("p",{parentName:"blockquote"},"Custom Flutter Engine Embedders",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://github.com/flutter/flutter/wiki/Custom-Flutter-Engine-Embedders"}),"https://github.com/flutter/flutter/wiki/Custom-Flutter-Engine-Embedders"))),Object(r.b)("h3",null,Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"在-android-中的-flutter"})),Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#在-android-中的-flutter"}),"#"),"在 Android 中的 Flutter"),Object(r.b)("p",null,"我们看一下创建 Flutter 项目中自动生成的 Android 工程，内部使用的是 io.flutter.app 包内的 FlutterActivity，暂且不讨论 io.flutter.embedding.android 包相关内容，后面会分析。"),Object(r.b)("p",null,"在 Android 中使用 Flutter 是这样的"),Object(r.b)("p",null,Object(r.b)("img",l({parentName:"p"},{src:"http://p0.qhimg.com/t012e1f4c21882aeeb2.png",alt:"io.flutter.app.Activity内容"}))),Object(r.b)("p",null,"如上图所示，图中罗列了一些类，这里讲解一下"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"FlutterView：Android 中用于展示 Flutter 页面的控件，一个 FlutterView 中可以展示多个 Flutter Widget，官方的注释是：",Object(r.b)("em",{parentName:"li"},'"An Android View containing a Flutter app"'),"。内部包含了 FlutterNativeView。"),Object(r.b)("li",{parentName:"ul"},"FlutterNativeView：每个 FlutterView 中包含一个FlutterNativeView，该类的主要作用是 Android 与 Flutter 之间的通信，保持生命周期与 Activity 及 FlutterView 同步。内部包含了 DartExecutor。"),Object(r.b)("li",{parentName:"ul"},"DartExecutor：根据名称我们可以了解，这个类就是 Dart VM 相关处理 Java 与 C/C++ 的调用。官方的注释是：",Object(r.b)("em",{parentName:"li"},'"Configures, bootstraps, and starts executing Dart code"'),"。")),Object(r.b)("p",null,"其实 Flutter 的运行机制就是这样的，Flutter 由 FlutterView 呈现。每一个 FlutterView，会对应的创建一个 FlutterNativeView，创建一个 Dart VM。而不同 FlutterView 内部的 Dart 代码内存无法共享。"),Object(r.b)("h3",null,Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"源码阅读"})),Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#源码阅读"}),"#"),"源码阅读"),Object(r.b)("p",null,"建议读者阅读一下代码"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"io.flutter.app.FlutterActivit",Object(r.b)("br",null),"Io.flutter.app.FlutterActivityDelegate",Object(r.b)("br",null),"io.flutter.view.FlutterMain",Object(r.b)("br",null),"io.flutter.view.FlutterView",Object(r.b)("br",null),"io.flutter.view.FlutterNativeView",Object(r.b)("br",null),"io.flutter.embedding.engine.dart.DartExecutor",Object(r.b)("br",null),"io.flutter.embedding.engine.FlutterJNI",Object(r.b)("br",null))),Object(r.b)("h3",null,Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"我们能做什么"})),Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#我们能做什么"}),"#"),"我们能做什么"),Object(r.b)("p",null,"通过上面的介绍，应该依然了解 Flutter 在 Android 上的运行机制，如果阅读了源码应该有更深的印象。在这样的运行机制中，我们能做什么呢？其实 Flutter Boost 框架给了我们解决的思路，但是这里我还是希望读者能自己来想想，如果是你自己来实现，该怎么做呢？"),Object(r.b)("h2",null,Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"三、混合栈处理框架"})),Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#三、混合栈处理框架"}),"#"),"三、混合栈处理框架"),Object(r.b)("p",null,"来看看社区为我们提供的方案吧。"),Object(r.b)("p",null,"网上的文章很多，在文章最后提供一些链接，有兴趣的读者可以都看一下。这里仅以 Flutter Boost 为例，来分析一下。"),Object(r.b)("p",null,"Flutter Boost 的处理方案可以分成两个版本，使用了两种方案，可以作为混合栈方案的两种代表思路。"),Object(r.b)("h3",null,Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"flutter-boost-004版本"})),Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#flutter-boost-004版本"}),"#"),"Flutter Boost 0.0.4+版本"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"alibaba/flutter_boost 0.0.420 ",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://github.com/alibaba/flutter_boost/releases/tag/0.0.420"}),"https://github.com/alibaba/flutter_boost/releases/tag/0.0.420"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"FlutterView 复用方案")),Object(r.b)("p",null,"框架中从 FlutterActivityDelegate#onCreate 方法入手，重写创建 FlutterView 的流程，复用 FlutterView 来实现。"),Object(r.b)("p",null,"我们先来看一下这个版本的接入方式，在 Application 中初始化"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),"    FlutterBoostPlugin.init(new IPlatform() {\n        ...\n          \n        /**\n         * 获取应用入口的Activity,这个Activity在应用交互期间应该是一直在栈底的\n         * 提供给框架内部，后续创建FlutterView用\n         */\n        @Override\n        public Activity getMainActivity() {\n            if (MainActivity.sRef != null) {\n                return MainActivity.sRef.get();\n            }\n            return null;\n        }\n        ...\n    });\n")),Object(r.b)("p",null,"我们来看一下 FlutterActivityDelegate#onCreate 是如何处理的。"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),"# FlutterActivityDelegate.java    \n        @Override\n    public void onCreate(Bundle savedInstanceState) {\n                ...\n                // 获取 flutterView\n        flutterView = viewFactory.createFlutterView(activity);\n        // 为空则创建，否则直接使用\n        if (flutterView == null) {\n                // 创建 FlutterView 的同时，创建 FlutterNative、DartExecutor\n            FlutterNativeView nativeView = viewFactory.createFlutterNativeView();\n            flutterView = new FlutterView(activity, null, nativeView);\n            flutterView.setLayoutParams(matchParent);\n            activity.setContentView(flutterView);\n            launchView = createLaunchView();\n            if (launchView != null) {\n                addLaunchView();\n            }\n        }\n      ...\n    }\n")),Object(r.b)("p",null,"createFlutterView 的实现是在 FlutterActivity 中的。"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),"# FlutterActivity.java\n    @Override\n    public FlutterView createFlutterView(Context context) {\n        return null;\n    }\n")),Object(r.b)("p",null,"而 Flutter Boost 框架重写了 createFlutterView 方法"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),"# BoostFlutterActivity.java\n        public FlutterView createFlutterView(Context context) {\n        return FlutterBoostPlugin.viewProvider().createFlutterView(this);\n    }\n")),Object(r.b)("p",null,"真正返回的是这里构造的"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),'# FlutterViewProvider.java\n        @Override\n    public BoostFlutterView createFlutterView(IFlutterViewContainer container) {\n            // 在 Application 中提供的 mPlatform，将缓存的 Activity 提供给这里\n        Activity activity = mPlatform.getMainActivity();\n\n        if(activity == null) {\n            Debuger.log("create Flutter View not with MainActivity");\n            activity = container.getActivity();\n        }\n        // 如果为 null 则创建然后缓存，有值则直接使用\n        if (mFlutterView == null) {\n                // BoostFlutterView 继承自 FlutterView\n            mFlutterView = new BoostFlutterView(activity, null, createFlutterNativeView(container));\n        }\n        return mFlutterView;\n    }\n')),Object(r.b)("p",null,"这样就复用了 FlutterView。"),Object(r.b)("p",null,"复用 FlutterView 需要在 Activity 切换的时候进行 view 的 attach、detach，该版本使用了截图方案。"),Object(r.b)("h3",null,Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"flutter-boost-015版本"})),Object(r.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#flutter-boost-015版本"}),"#"),"Flutter Boost 0.1.5+版本"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"FlutterEngine 复用")),Object(r.b)("p",null,"从接入方式来看，在 Application 中初始化，提供了一个回调方法，提供 BoostFlutterEngine 即是 FlutterEngine 实例。"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),'    FlutterBoost.init(new Platform() {\n        ...\n        @Override\n        public IFlutterEngineProvider engineProvider() {\n            return new BoostEngineProvider() {\n                @Override\n                public BoostFlutterEngine createEngine(Context context) {\n                    return new BoostFlutterEngine(context, new DartExecutor.DartEntrypoint(\n                            context.getResources().getAssets(),\n                            FlutterMain.findAppBundlePath(context),\n                            "main"), "/");\n                }\n            };\n        }\n        ...\n    });\n')),Object(r.b)("p",null,"在看 BoostFlutterActivity 实现"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),"    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n                ...\n        mFlutterEngine = createFlutterEngine();\n        mFlutterView = createFlutterView(mFlutterEngine);\n        setContentView(mFlutterView);\n                ...\n    }\n        ...\n    protected BoostFlutterEngine createFlutterEngine(){\n        return FlutterBoost.singleton().engineProvider().provideEngine(this);\n    }\n")),Object(r.b)("p",null,"真正返回的是这里构造的"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"})," # com.idlefish.flutterboost.BoostEngineProvider\n        @Override\n    public BoostFlutterEngine provideEngine(Context context) {\n        Utils.assertCallOnMainThread();\n\n        if (mEngine == null) {\n            FlutterShellArgs flutterShellArgs = new FlutterShellArgs(new String[0]);\n            FlutterMain.ensureInitializationComplete(\n                    context.getApplicationContext(), flutterShellArgs.toArray());\n                        // 这里调用的方法就是初始化时重写内容\n            mEngine = createEngine(context.getApplicationContext());\n\n            final IStateListener stateListener = FlutterBoost.sInstance.mStateListener;\n            if(stateListener != null) {\n                stateListener.onEngineCreated(mEngine);\n            }\n        }\n        return mEngine;\n    }\n")),Object(r.b)("p",null,"该版本的处理方式与 io.flutter.embedding 包中处理方式基本相同，使用了 flutter.jar 中的 FlutterSurfaceView 和 FlutterTextureView 来最终的展示 Flutter 界面。接下来我们看看 Flutter 官方为我们提供的方式。"),Object(r.b)("h2",null,Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"官方提供的方式"})),Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#官方提供的方式"}),"#"),"官方提供的方式"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Experimental: Adding Flutter to Android",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://github.com/flutter/flutter/wiki/Experimental:-Adding-Flutter-to-Android"}),"https://github.com/flutter/flutter/wiki/Experimental:-Adding-Flutter-to-Android"))),Object(r.b)("p",null,"通过文档我们就可以知道，该方式和 Flutter 项目自动生成的 Android 工程不同，使用的大多为 io.flutter.embedding 包中的内容，并且提供了使用缓存的 FlutterEngine 的方式。使用了 FlutterEngineCache 类进行对 FlutterEngine 的 key-value 缓存。"),Object(r.b)("p",null,"在 flutter.jar 中可以看到，共存了两个 FlutterActivity、FlutterView 等。"),Object(r.b)("p",null,"FlutterActivity"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"io.flutter.app.FlutterActivity",Object(r.b)("br",null),"io.flutter.embedding.FlutterActivity ")),Object(r.b)("p",null,"FlutterView"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"io.flutter.view.FlutterView",Object(r.b)("br",null),"io.flutter.embedding.FlutterView")),Object(r.b)("p",null,"这里简单介绍一下"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),"# io.flutter.embedding.FlutterActivity.java\n    @Override\n  protected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    ...\n    delegate = new FlutterActivityAndFragmentDelegate(this);\n    // 创建 Flutter\n    // 提供 FlutterEngine 并绑定到 Activity、创建并配置 PlatformPlugin、\n    delegate.onAttach(this);\n    ...\n    // 创建 Flutter 的 View 并绑定到 Activity\n    setContentView(createFlutterView());\n    ...\n  }\n    @NonNull\n  private View createFlutterView() {\n    return delegate.onCreateView(\n        null /* inflater */,\n        null /* container */,\n        null /* savedInstanceState */);\n  }\n")),Object(r.b)("p",null,"加载到 Activity 上的 View 是如何创建的"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),"# io.flutter.embedding.android.FlutterActivityAndFragmentDelegate.java  \n    @NonNull\n  View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        ...\n        // 创建了一个 FlutterView\n    flutterView = new FlutterView(host.getActivity(), host.getRenderMode(), host.getTransparencyMode());\n        // 创建了一个 FlutterSplashView，包裹了一个 FlutterView 的View\n    flutterSplashView = new FlutterSplashView(host.getContext());\n        ...\n        // 在 FlutterView 展示第一帧之前，先展示提供的 splashScreen\n    flutterSplashView.displayFlutterViewWithSplash(flutterView, host.provideSplashScreen());\n\n    return flutterSplashView;\n  }\n")),Object(r.b)("p",null,"看一下 FlutterView 是如何实现的"),Object(r.b)("pre",null,Object(r.b)("code",l({parentName:"pre"},{className:"language-java"}),"  private void init() {\n        // 根据 renderMode 模式来选择使用 SurfaceView/TextureView，解决了 SurfaceView 对动画支持差的诟病\n    switch (renderMode) {\n      case surface:\n        FlutterSurfaceView flutterSurfaceView = new FlutterSurfaceView(getContext(), transparencyMode == TransparencyMode.transparent);\n        renderSurface = flutterSurfaceView;\n        addView(flutterSurfaceView);\n        break;\n      case texture:\n        FlutterTextureView flutterTextureView = new FlutterTextureView(getContext());\n        renderSurface = flutterTextureView;\n        addView(flutterTextureView);\n        break;\n    }\n    setFocusable(true);\n    setFocusableInTouchMode(true);\n  }\n")),Object(r.b)("p",null,"大致的流程就是这样的。"),Object(r.b)("h2",null,Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"小结"})),Object(r.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#小结"}),"#"),"小结"),Object(r.b)("p",null,"Flutter 的混合栈处理在这一年多内，也有了很大的发展，从整个发展历程来梳理，可能对混合栈的方案有更深的理解。最后附上整理的混合栈相关文章"),Object(r.b)("p",null,"Flutter 混合栈处理相关文章："),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"码上用它开始 Flutter 混合开发——FlutterBoos",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://my.oschina.net/yunqi/blog/3038039"}),"https://my.oschina.net/yunqi/blog/3038039")),Object(r.b)("p",{parentName:"blockquote"},"Flutter 新锐专家之路：混合开发片",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://juejin.im/post/5b764acb51882532dc1812b1"}),"https://juejin.im/post/5b764acb51882532dc1812b1")),Object(r.b)("p",{parentName:"blockquote"},"微店的 Flutter 混合栈管理技术实践",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://juejin.im/post/5c419c07f265da616f703aa1"}),"https://juejin.im/post/5c419c07f265da616f703aa1")),Object(r.b)("p",{parentName:"blockquote"},"Flutter 实现原理及在马蜂窝的跨平台开发事件",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://juejin.im/post/5d37b328518825453b6057b2"}),"https://juejin.im/post/5d37b328518825453b6057b2")),Object(r.b)("p",{parentName:"blockquote"},"让 Flutter 真正支持 View级别的混合开发",Object(r.b)("br",null),Object(r.b)("a",l({parentName:"p"},{href:"https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485002&idx=1&sn=42d8683ec7777dbd1737c431edef1716&chksm=e9d0cda8dea744bebeb19e2cb025bab79dc38fae568f6a3e2b00b88514da88b7928c03ecbf56&sessionid=1570763650&scene=126&subscene=0&clicktime=1570763683&ascene=3&devicetype=android-28&version=27000536&nettype=WIFI&abtest_cookie=BAABAAoACwASABMABAAjlx4AVpkeAL2ZHgD4mR4AAAA%3D&lang=zh_CN&pass_ticket=dcVAZN9GBaJFUZApeVBRXeX9nT7JeHZRM3Jf%2BgtUJVS0idNTtObtYwh2dlc84G3D&wx_header=1"}),"https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485002&idx=1&sn=42d8683ec7777dbd1737c431edef1716&chksm=e9d0cda8dea744bebeb19e2cb025bab79dc38fae568f6a3e2b00b88514da88b7928c03ecbf56&sessionid=1570763650&scene=126&subscene=0&clicktime=1570763683&ascene=3&devicetype=android-28&version=27000536&nettype=WIFI&abtest_cookie=BAABAAoACwASABMABAAjlx4AVpkeAL2ZHgD4mR4AAAA%3D&lang=zh_CN&pass_ticket=dcVAZN9GBaJFUZApeVBRXeX9nT7JeHZRM3Jf%2BgtUJVS0idNTtObtYwh2dlc84G3D&wx_header=1"))))}o.isMDXComponent=!0}}]);