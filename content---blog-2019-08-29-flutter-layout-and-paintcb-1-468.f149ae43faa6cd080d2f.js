(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{45:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return o}),t.d(n,"rightToc",function(){return d}),t.d(n,"default",function(){return c});t(0);var i=t(105);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e}).apply(this,arguments)}function r(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o={title:"Flutter的布局和绘制",author:"handoing",authorTitle:"A flutter fans",authorURL:"https://github.com/handoing",authorImageURL:"https://p5.ssl.qhimg.com/t01b6580ec3d65d7b7f.png",tags:["flutter","widget"]},d=[{value:"Flutter的布局和绘制",id:"flutter的布局和绘制",children:[{value:"实现流程",id:"实现流程",children:[]},{value:"关于布局约束",id:"关于布局约束",children:[]},{value:"自定义布局和绘制示例：",id:"自定义布局和绘制示例：",children:[]}]}],l={rightToc:d},s="wrapper";function c(e){var n=e.components,t=r(e,["components"]);return Object(i.b)(s,a({},l,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h2",null,Object(i.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"flutter的布局和绘制"})),Object(i.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#flutter的布局和绘制"}),"#"),"Flutter的布局和绘制"),Object(i.b)("p",null,"本次主要讲解flutter如何实现布局和绘制，默认大家已学习过",Object(i.b)("a",a({parentName:"p"},{href:"https://www.fluttercn.dev/blog/2019/08/11/flutter-render"}),"《Flutter从加载到显示》")),Object(i.b)("p",null,"当flutter接收到系统发送来的Vsync信号时，会连续执行动画、构建、布局、绘制一系列操作，最后输出Sence（layer tree）并传递给flutter engine进行后续操作，其中绿色部分是本次要讲的内容，这里说明一下，在flutter里，layout和paint阶段操作的是RenderObject tree。"),Object(i.b)("p",null,"flutter rendering pipeline，如图："),Object(i.b)("img",{src:"http://p0.qhimg.com/t014b88997d0c84c319.png",width:"100%"}),Object(i.b)("h3",null,Object(i.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"实现流程"})),Object(i.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#实现流程"}),"#"),"实现流程"),Object(i.b)("h4",null,Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"anchor",id:"1-drawframe"})),Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"hash-link",href:"#1-drawframe"}),"#"),"1. drawFrame"),Object(i.b)("p",null,"我们首先看一下drawFrame执行了哪些操作"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable {\n  ...\n    \n  @protected\n  void drawFrame() {\n    // PipelineOwner负责管理renderObject tree的渲染\n    pipelineOwner.flushLayout(); // 对RenderObject进行布局操作\n    pipelineOwner.flushCompositingBits(); // 对layer tree做相关处理\n    pipelineOwner.flushPaint(); // 对RenderObject进行绘制操作\n    renderView.compositeFrame(); // 传递sence给engine做后续操作\n    pipelineOwner.flushSemantics(); // 处理语义相关操作\n  }\n  ...\n}\n")),Object(i.b)("h4",null,Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"anchor",id:"2-flushlayout"})),Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"hash-link",href:"#2-flushlayout"}),"#"),"2. flushLayout"),Object(i.b)("p",null,"flushLayout里会遍历 _nodesNeedingLayout (当节点需要布局时会被添加到这个数组)，并调用 _layoutWithoutResize 方法。"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"void flushLayout() {\n  while (_nodesNeedingLayout.isNotEmpty) {\n    final List<RenderObject> dirtyNodes = _nodesNeedingLayout;\n    _nodesNeedingLayout = <RenderObject>[];\n    for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => a.depth - b.depth)) {\n      if (node._needsLayout && node.owner == this)\n        node._layoutWithoutResize();\n      }\n    }\n  }\n}\n")),Object(i.b)("p",null,"_layoutWithoutResize 方法里执行performLayout，并调用markNeedsPaint标记节点dirty状态。"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"void _layoutWithoutResize() {\n  try {\n    performLayout();\n    markNeedsSemanticsUpdate();\n  } catch (e, stack) {\n    _debugReportException('performLayout', e, stack);\n  }\n  _needsLayout = false;\n  markNeedsPaint();\n}\n")),Object(i.b)("h4",null,Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"anchor",id:"3-flushpaint"})),Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"hash-link",href:"#3-flushpaint"}),"#"),"3. flushPaint"),Object(i.b)("p",null,"跳过flushCompositingBits（不作为本次讲解内容），我们继续看flushPaint，当节点对应的layer被挂载后会调用repaintCompositedChild"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"void flushPaint() {\n  final List<RenderObject> dirtyNodes = _nodesNeedingPaint;\n  _nodesNeedingPaint = <RenderObject>[];\n  for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => b.depth - a.depth)) {\n    if (node._needsPaint && node.owner == this) {\n      if (node._layer.attached) {\n        PaintingContext.repaintCompositedChild(node);\n      } else {\n        node._skippedPaintingOnLayer();\n      }\n    }\n  }\n}\n")),Object(i.b)("p",null,"继续调用 _repaintCompositedChild"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"static void repaintCompositedChild(RenderObject child, { bool debugAlsoPaintedParent = false }) {\n  _repaintCompositedChild(\n    child,\n    debugAlsoPaintedParent: debugAlsoPaintedParent,\n  );\n}\n")),Object(i.b)("p",null,"调用 _paintWithContext"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"static void _repaintCompositedChild(\n  RenderObject child, {\n  bool debugAlsoPaintedParent = false,\n  PaintingContext childContext,\n}) {\n  if (child._layer == null) {\n    child._layer = OffsetLayer();\n  } else {\n    child._layer.removeAllChildren();\n  }\n  childContext ??= PaintingContext(child._layer, child.paintBounds);\n  child._paintWithContext(childContext, Offset.zero);\n  childContext.stopRecordingIfNeeded();\n}\n")),Object(i.b)("p",null,"调用了renderObject的paint方法进行绘制操作，并传入context和offset"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"void _paintWithContext(PaintingContext context, Offset offset) {\n  if (_needsLayout)\n    return;\n  RenderObject debugLastActivePaint;\n  _needsPaint = false;\n  try {\n    paint(context, offset);\n  } catch (e, stack) {\n    _debugReportException('paint', e, stack);\n  }\n}\n")),Object(i.b)("h3",null,Object(i.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"关于布局约束"})),Object(i.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#关于布局约束"}),"#"),"关于布局约束"),Object(i.b)("p",null,"在Flutter中，布局采用的是约束（constraints）模型。父元素通过传递约束给子元素，子元素可在这些约束下调整自身大小。"),Object(i.b)("img",{src:"http://p0.qhimg.com/t01f0cf58282f8f7192.png",width:"100%"}),Object(i.b)("p",null,"flutter里面有两种约束类型："),Object(i.b)("p",null,"1.BoxConstraint（盒约束）"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"const BoxConstraints({\n  this.minWidth = 0.0,\n  this.maxWidth = double.infinity,\n  this.minHeight = 0.0,\n  this.maxHeight = double.infinity,\n});\n")),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"Size(double width, double height)\n")),Object(i.b)("p",null,"2.SliverConstraint（滚动相关约束）"),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"const SliverConstraints({\n  @required this.axisDirection,\n  @required this.growthDirection,\n  @required this.userScrollDirection,\n  @required this.scrollOffset,\n  @required this.precedingScrollExtent,\n  @required this.overlap,\n  @required this.remainingPaintExtent,\n  @required this.crossAxisExtent,\n  @required this.crossAxisDirection,\n  @required this.viewportMainAxisExtent,\n  @required this.remainingCacheExtent,\n  @required this.cacheOrigin,\n})\n")),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"const SliverGeometry({\n  this.scrollExtent = 0.0,\n  this.paintExtent = 0.0,\n  this.paintOrigin = 0.0,\n  double layoutExtent,\n  this.maxPaintExtent = 0.0,\n  this.maxScrollObstructionExtent = 0.0,\n  double hitTestExtent,\n  bool visible,\n  this.hasVisualOverflow = false,\n  this.scrollOffsetCorrection,\n  double cacheExtent,\n})\n")),Object(i.b)("h3",null,Object(i.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"自定义布局和绘制示例："})),Object(i.b)("a",a({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#自定义布局和绘制示例："}),"#"),"自定义布局和绘制示例："),Object(i.b)("p",null,"1.单Widget"),Object(i.b)("p",null,"实现简单居中布局，截屏如图："),Object(i.b)("div",{align:"center"},Object(i.b)("img",{src:"http://p0.qhimg.com/t01bae4861bbef9063b.png",width:"400px"})),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n// 继承SingleChildRenderObjectWidget并重写createRenderObject方法，返回自定义的RenderMyCenter\nclass MyCenter extends SingleChildRenderObjectWidget {\n\n  MyCenter({Widget child}): super(child: child);\n\n  @override\n  RenderObject createRenderObject(BuildContext context) {\n    return RenderMyCenter();\n  }\n}\n\n// 继承RenderShiftedBox并重写performLayout实现布局，RenderShiftedBox最终继承自RenderObject\nclass RenderMyCenter extends RenderShiftedBox {\n  RenderMyCenter(): super(null);\n\n  @override\n  void performLayout() {\n\n    // 通过调用child的layout方法向子节点传递约束\n    child.layout(\n        BoxConstraints(\n            minHeight: 0.0,\n            maxHeight: this.constraints.minHeight,\n            minWidth: 0.0,\n            maxWidth: this.constraints.minWidth\n        ),\n        parentUsesSize: true\n    );\n\n    final BoxParentData childParentData = child.parentData;\n    // 设置偏移量，使child居中\n    childParentData.offset = Offset((constraints.maxWidth - child.size.width) / 2, (constraints.maxHeight - child.size.height) / 2);\n\n    // 设置大小，使得其父元素可以拿到当前节点的size\n    size = Size(constraints.maxWidth, constraints.maxHeight);\n  }\n\n}\n")),Object(i.b)("p",null,"2.多Widget"),Object(i.b)("p",null,"实现简单横向布局Widget，定义两个子Widget，截屏如图："),Object(i.b)("div",{align:"center"},Object(i.b)("img",{src:"http://p0.qhimg.com/t018d4d7209c11a2581.png",width:"400px"})),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"// 实现多Widget需继承MultiChildRenderObjectWidget，重写createRenderObject\nclass MyRow extends MultiChildRenderObjectWidget {\n  MyRow({\n    Key key,\n    List<Widget> children = const <Widget>[],\n  }) : super(key: key, children: children);\n\n  @override\n  RenderObject createRenderObject(BuildContext context) {\n    return RenderMyRow();\n  }\n}\n\n// 定义MyMultiChildLayoutParentData，当RenderMyRow mixins时需传入当前类型\nclass MyMultiChildLayoutParentData extends ContainerBoxParentData<RenderBox> {\n  @override\n  String toString() => '${super.toString()};';\n}\n\nclass MySub extends ParentDataWidget<MyRow> {\n  MySub({Key key, @required Widget child}) : super(key: key, child: child);\n\n  @override\n  void applyParentData(RenderObject renderObject) {\n    // 可通过applyParentData对renderObject进行一些赋值操作，以便布局中可通过ParentData拿到相关信息，本示例未用到\n  }\n\n}\n\nclass RenderMyRow extends RenderBox with ContainerRenderObjectMixin<RenderBox, MyMultiChildLayoutParentData>,\n    RenderBoxContainerDefaultsMixin<RenderBox, MyMultiChildLayoutParentData> {\n\n  RenderMyRow({ List<RenderBox> children }) {\n    addAll(children);\n  }\n\n  @override\n  void setupParentData(RenderBox child) {\n    if (child.parentData is! MyMultiChildLayoutParentData)\n      child.parentData = MyMultiChildLayoutParentData();\n  }\n\n  @override\n  void performLayout() {\n    // 拿到第一个子节点\n    RenderBox child = firstChild;\n    // 传递约束\n    child.layout(BoxConstraints(\n      minHeight: 0.0,\n      maxHeight: constraints.maxHeight,\n      minWidth: 0.0,\n      maxWidth: constraints.maxWidth / 2,\n    ), parentUsesSize: true);\n    MyMultiChildLayoutParentData childParentData = child.parentData;\n    // 定义偏移使其水平居左，垂直居中\n    childParentData.offset = Offset(0, (constraints.maxHeight - child.size.height) / 2);\n\n    // 通过nextSibling拿到第二个子节点\n    child = childParentData.nextSibling;\n    // 传递约束\n    child.layout(BoxConstraints(\n      minHeight: 0.0,\n      maxHeight: constraints.maxHeight,\n      minWidth: 0.0,\n      maxWidth: constraints.maxWidth / 2,\n    ), parentUsesSize: true);\n    childParentData = child.parentData;\n    // 定义偏移使其水平居右，垂直居中\n    childParentData.offset = Offset(constraints.maxWidth - child.size.width, (constraints.maxHeight - child.size.height) / 2);\n\n    // 定义大小\n    size = Size(constraints.maxWidth, constraints.maxHeight);\n\n  }\n\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    RenderBox child = firstChild;\n    while (child != null) {\n      final MyMultiChildLayoutParentData childParentData = child.parentData;\n      // 直接交由子元素绘制\n      context.paintChild(child, childParentData.offset + offset);\n      child = childParentData.nextSibling;\n    }\n  }\n}\n")),Object(i.b)("p",null,"3.自定义Button"),Object(i.b)("p",null,"自定义button，当被点击触发圆圈扩散动画"),Object(i.b)("div",{align:"center"},Object(i.b)("img",{src:"http://p0.qhimg.com/t015c363517765f10c6.gif",width:"400px"})),Object(i.b)("pre",null,Object(i.b)("code",a({parentName:"pre"},{className:"language-js"}),"class Options {\n  Options({\n    this.radius,\n    this.status,\n    this.tapPosition,\n    this.color,\n  });\n\n  final double radius;\n  final AnimationStatus status;\n  final Offset tapPosition;\n  final Color color;\n}\n\nclass MyButton extends StatefulWidget {\n  MyButton({\n    Key key,\n    this.onTap,\n    this.child,\n    this.color,\n  }) : super(key: key);\n\n  final Widget child;\n\n  final GestureTapCallback onTap;\n\n  final Color color;\n\n  @override\n  _MyButtonState createState() => _MyButtonState();\n}\n\nclass _MyButtonState extends State<MyButton> with SingleTickerProviderStateMixin {\n\n  AnimationController controller;\n  Tween<double> radiusTween;\n  Animation<double> radiusAnimation;\n  AnimationStatus status;\n  Offset _tapPosition;\n\n  @override\n  void initState() {\n    controller = AnimationController(vsync: this, duration: Duration(milliseconds: 400))\n      ..addListener(() {\n        setState(() {});\n      })\n      ..addStatusListener((AnimationStatus listener) {\n        status = listener;\n      });\n\n    radiusTween = Tween<double>(begin: 0, end: 40);\n    radiusAnimation = radiusTween\n        .animate(CurvedAnimation(curve: Curves.ease, parent: controller));\n\n    super.initState();\n  }\n\n  void _animate() {\n    controller.forward(from: 0);\n  }\n\n  void _handleTap(TapUpDetails tapDetails) {\n\n    final RenderBox renderBox = context.findRenderObject();\n\n    _tapPosition = renderBox.globalToLocal(tapDetails.globalPosition);\n    _animate();\n\n    widget.onTap();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MyBtn(\n        child: GestureDetector(\n          child: widget.child,\n          onTapUp: _handleTap,\n        ),\n        options: Options(\n          radius: radiusAnimation.value,\n          status: status,\n          tapPosition: _tapPosition,\n          color: widget.color,\n        )\n    );\n  }\n\n  @override\n  void dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}\n\n// 继承SingleChildRenderObjectWidget\nclass MyBtn extends SingleChildRenderObjectWidget {\n\n  MyBtn({\n    Widget child,\n    @required this.options,\n  }): super(child: child);\n\n  final Options options;\n\n  @override\n  RenderObject createRenderObject(BuildContext context) {\n    return RenderMyBtn(\n        options: options\n    );\n  }\n\n  @override\n  void updateRenderObject(BuildContext context, RenderMyBtn renderObject) {\n    // 重新赋值options\n    renderObject\n      ..options = options;\n  }\n\n}\n\n// 继承RenderProxyBox\nclass RenderMyBtn extends RenderProxyBox {\n\n  RenderMyBtn({\n    Options options\n  }) : _options = options,\n        super();\n\n  Options get options => _options;\n  Options _options;\n  set options(Options value) {\n    _options = value;\n    // 当options被赋值时标记当前节点需要绘制\n    markNeedsPaint();\n  }\n\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    super.paint(context, offset);\n\n    Paint paint = Paint()\n      ..color = _options.color\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 2;\n\n    Canvas canvas = context.canvas;\n\n    canvas.translate(offset.dx, offset.dy);\n    // 绘制边框\n    canvas.drawRect(Rect.fromLTWH(0, 0, child.size.width, child.size.height), paint);\n\n    if (_options.status == AnimationStatus.forward) {\n        // 绘制圆\n      canvas.drawCircle(_options.tapPosition, _options.radius, paint);\n    }\n\n  }\n\n}\n")),Object(i.b)("h4",null,Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"anchor",id:"问题：重布局和重绘？"})),Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"hash-link",href:"#问题：重布局和重绘？"}),"#"),"问题：重布局和重绘？"),Object(i.b)("p",null,"1.当某个节点的size变了，整个视图树需要重新计算？"),Object(i.b)("p",null,"通过设置relayoutBoundary，使得边界内的节点做任何改变都不会导致边界外的节点重新布局。"),Object(i.b)("p",null,"2.如何避免图层内其他节点重绘？"),Object(i.b)("p",null,"通过RepaintBoundary组件或直接设置renderObject的isRepaintBoundary为true"),Object(i.b)("p",null,"有兴趣的同学可自行验证"),Object(i.b)("h4",null,Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"anchor",id:"demo"})),Object(i.b)("a",a({parentName:"h4"},{"aria-hidden":!0,className:"hash-link",href:"#demo"}),"#"),"demo"),Object(i.b)("p",null,Object(i.b)("a",a({parentName:"p"},{href:"https://github.com/handoing/flutter_layout_and_paint"}),"https://github.com/handoing/flutter_layout_and_paint")))}c.isMDXComponent=!0}}]);