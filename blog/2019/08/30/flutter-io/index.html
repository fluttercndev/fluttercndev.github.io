<!DOCTYPE html>
<html lang=&#34;en&#34; data-theme=&#34;&#34;>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script type="text/javascript">/*<![CDATA[*/window.__chunkMapping={"main":["/main.cce358011c7da27efa46.css","/main.cce358011c7da27efa46.js"],"component---users-wangjianbing-project-fluttercn-dev-src-pages-index-js-8-f-8-fe8":["/component---users-wangjianbing-project-fluttercn-dev-src-pages-index-js-8-f-8-fe8.d15de7da6ae110ab3e0a.css","/component---users-wangjianbing-project-fluttercn-dev-src-pages-index-js-8-f-8-fe8.d15de7da6ae110ab3e0a.js"],"metadata---a-64-e52":["/metadata---a-64-e52.df32209107e377ad2ba2.js"],"component---theme-blog-post-pageccc-cab":[],"content---blog-2019-10-11-flutter-hybrid-explain-07-f-809":["/content---blog-2019-10-11-flutter-hybrid-explain-07-f-809.af817808ed1629a916a1.js"],"metadata---blog-2019-10-11-flutter-hybrid-explain-680-3e4":["/metadata---blog-2019-10-11-flutter-hybrid-explain-680-3e4.51a2a7478739c093e7d6.js"],"nextItem---blog-2019-10-11-flutter-hybrid-explain-883-5d4":["/nextItem---blog-2019-10-11-flutter-hybrid-explain-883-5d4.636727ecc735dfbf83ec.js"],"content---blog-2019-08-30-flutter-io-633-c2e":["/content---blog-2019-08-30-flutter-io-633-c2e.2afd21e6c6b6ff67737c.js"],"nextItem---blog-2019-08-30-flutter-io-5-a-1-61e":["/nextItem---blog-2019-08-30-flutter-io-5-a-1-61e.106c7db7d1aa7fce6d74.js"],"content---blog-2019-08-29-flutter-layout-and-paintcb-1-468":["/content---blog-2019-08-29-flutter-layout-and-paintcb-1-468.f149ae43faa6cd080d2f.js"],"nextItem---blog-2019-08-29-flutter-layout-and-paint-944-f1c":["/nextItem---blog-2019-08-29-flutter-layout-and-paint-944-f1c.d99b84ed52b2d905c27a.js"],"content---blog-2019-08-14-flutter-platform-channel-0-fe-961":["/content---blog-2019-08-14-flutter-platform-channel-0-fe-961.13cf50ad94d1289297ad.js"],"nextItem---blog-2019-08-14-flutter-platform-channel-7-ed-a0b":["/nextItem---blog-2019-08-14-flutter-platform-channel-7-ed-a0b.8d53cbcdf2edd8628647.js"],"content---blog-2019-08-11-flutter-render-309-808":["/content---blog-2019-08-11-flutter-render-309-808.c9c8af3a1b920da7c7b3.js"],"nextItem---blog-2019-08-11-flutter-renderf-90-acb":["/nextItem---blog-2019-08-11-flutter-renderf-90-acb.ee6e4c739c8154e570cd.js"],"content---blog-2019-08-09-flutter-platform-view-31-b-d5a":["/content---blog-2019-08-09-flutter-platform-view-31-b-d5a.2ad129727fd6b99df5da.js"],"nextItem---blog-2019-08-09-flutter-platform-view-09-e-95e":["/nextItem---blog-2019-08-09-flutter-platform-view-09-e-95e.e56f797c1c0d2a3a8753.js"],"content---blog-2019-07-29-flutter-image-00-f-3c9":["/content---blog-2019-07-29-flutter-image-00-f-3c9.da2416adde3a61b11cd0.js"],"nextItem---blog-2019-07-29-flutter-imagef-9-b-2cd":["/nextItem---blog-2019-07-29-flutter-imagef-9-b-2cd.fba56f256109f793d950.js"],"content---blog-2019-07-23-flutter-texte-7-f-5e3":["/content---blog-2019-07-23-flutter-texte-7-f-5e3.470f1ae10bf03f858b6e.js"],"nextItem---blog-2019-07-23-flutter-text-491-9fd":["/nextItem---blog-2019-07-23-flutter-text-491-9fd.9fb532a04c79d1240121.js"],"content---blog-2019-07-16-dart-basis-4571-109":["/content---blog-2019-07-16-dart-basis-4571-109.85d1b2f22be1a4c1198c.js"],"nextItem---blog-2019-07-16-dart-basis-4-d-07-edf":["/nextItem---blog-2019-07-16-dart-basis-4-d-07-edf.aefac2eaff13f80991f6.js"],"content---blog-2019-07-15-dart-basis-3-de-0-611":["/content---blog-2019-07-15-dart-basis-3-de-0-611.be4e2d830236c8fd2c68.js"],"nextItem---blog-2019-07-15-dart-basis-3-c-72-cb6":["/nextItem---blog-2019-07-15-dart-basis-3-c-72-cb6.5a0273e64af8191cbc7c.js"],"content---blog-2019-07-14-dart-basis-2401-3b5":["/content---blog-2019-07-14-dart-basis-2401-3b5.212fc928f85603bfd0cb.js"],"nextItem---blog-2019-07-14-dart-basis-2074-310":["/nextItem---blog-2019-07-14-dart-basis-2074-310.9b6a0876f6496f86c46a.js"],"content---blog-2019-07-13-dart-basis-11-d-6-128":["/content---blog-2019-07-13-dart-basis-11-d-6-128.4e92e8450593f52a9493.js"],"nextItem---blog-2019-07-13-dart-basis-1220-dd2":["/nextItem---blog-2019-07-13-dart-basis-1220-dd2.8fe561164e8328d2e9a3.js"],"content---blog-2019-07-12-flutter-widget-videosc-9-f-72c":["/content---blog-2019-07-12-flutter-widget-videosc-9-f-72c.6ab14c5cda6b0a173503.js"],"component---theme-doc-legacy-page-9-e-7-ca5":[],"docsMetadata---docs-219-f23":["/docsMetadata---docs-219-f23.ee7c76f4a45bf0253546.js"],"component---theme-doc-legacy-item-031-769":[],"content---docs-doc-1-d-42-e1f":["/content---docs-doc-1-d-42-e1f.9801686b8d41814ed576.js"],"metadata---docs-doc-187-a-aee":["/metadata---docs-doc-187-a-aee.b48738b9271195f0fe54.js"],"content---docs-doc-2-c-2-e-e91":["/content---docs-doc-2-c-2-e-e91.14c1c7e2150ed6ded4a3.js"],"metadata---docs-doc-2-dc-7-408":["/metadata---docs-doc-2-dc-7-408.83174d4cd91b3ace2a13.js"],"content---docs-doc-3688-ea2":["/content---docs-doc-3688-ea2.217cb3a99c6bd5dafc23.js"],"metadata---docs-doc-31-f-9-209":["/metadata---docs-doc-31-f-9-209.24a0dc2a33675a78ff58.js"],"content---docs-mdx-442-733":["/content---docs-mdx-442-733.b34ee68d263a3e07a645.js"],"metadata---docs-mdxb-5-a-c9d":["/metadata---docs-mdxb-5-a-c9d.2f67a5d332f7a4a16edf.js"],"component---theme-blog-list-pagea-6-a-7ba":[],"content---blog-16-d-aca":["/content---blog-16-d-aca.651e5449446a0b8ec69e.js"],"content---blogf-34-924":["/content---blogf-34-924.2e2f108c63393055ecfb.js"],"content---bloga-3-e-946":["/content---bloga-3-e-946.0929cdd848eca32089b9.js"],"content---blogdb-9-70f":["/content---blogdb-9-70f.b9c066a7a24446e8c731.js"],"content---blog-76-b-6a5":["/content---blog-76-b-6a5.7ddf003aed75b810096a.js"],"content---blog-33-c-c1d":["/content---blog-33-c-c1d.1028a6163b4abe04512b.js"],"content---blog-7-a-4-f34":["/content---blog-7-a-4-f34.bc96f98191bfb00c4ff5.js"],"content---bloge-13-1a7":["/content---bloge-13-1a7.8b8b3d4666c8be34eef6.js"],"content---blog-32-d-e46":["/content---blog-32-d-e46.17365dce2096fb69d5da.js"],"content---blog-093-e63":["/content---blog-093-e63.af8e15d37baf5a317c96.js"],"metadata---blog-2-db-770":["/metadata---blog-2-db-770.be34e74057b4bf7d13ec.js"],"content---blog-page-2-ba-9-606":["/content---blog-page-2-ba-9-606.e496c76e95df4b6f81db.js"],"content---blog-page-2021-96f":["/content---blog-page-2021-96f.294bc0d83c44e54f6cfb.js"],"content---blog-page-2350-fca":["/content---blog-page-2350-fca.22f304d672d61dd4a467.js"],"metadata---blog-page-29-ac-584":["/metadata---blog-page-29-ac-584.a034ad86d46157e071b6.js"],"component---theme-blog-tags-posts-page-687-b6c":[],"metadata---blog-tags-flutter-320-292":["/metadata---blog-tags-flutter-320-292.aeb6dde98cca69865101.js"],"metadata---blog-tags-hybrid-416-b77":["/metadata---blog-tags-hybrid-416-b77.56bf4c8ca5dc99bd91e0.js"],"metadata---blog-tags-widget-713-3a7":["/metadata---blog-tags-widget-713-3a7.c417e05424302394e71e.js"],"metadata---blog-tags-io-20-a-983":["/metadata---blog-tags-io-20-a-983.b838a1a3e27d21298abe.js"],"metadata---blog-tags-dartcbf-34e":["/metadata---blog-tags-dartcbf-34e.7b7d4eac74898bd72c2f.js"],"metadata---blog-tags-platform-viewf-71-08e":["/metadata---blog-tags-platform-viewf-71-08e.fd81e1a2e0eb5ccbb23e.js"],"metadata---blog-tags-basicc-82-d21":["/metadata---blog-tags-basicc-82-d21.2f08dce8a001b63ce91c.js"],"metadata---blog-tags-video-577-edd":["/metadata---blog-tags-video-577-edd.16e822ea9a534446f0e2.js"],"component---theme-blog-tags-list-page-01-a-d0b":[],"tags---blog-tags-958-e2f":["/tags---blog-tags-958-e2f.8245beaac7c1bd1ca442.js"]};/*]]>*/</script>

<title data-react-helmet="true">Flutter之请求</title>

<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="viewport" content="width=device-width"/><meta data-react-helmet="true" property="og:title" content="Flutter之请求"/><meta data-react-helmet="true" name="description" content="## 1.网络请求的常见使用"/><meta data-react-helmet="true" property="og:description" content="## 1.网络请求的常见使用"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/>

<link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"/>


<link rel="stylesheet" type="text/css" href="/main.cce358011c7da27efa46.css" />

<link rel="stylesheet" type="text/css" href="/component---users-wangjianbing-project-fluttercn-dev-src-pages-index-js-8-f-8-fe8.d15de7da6ae110ab3e0a.css" />

<link rel="stylesheet" type="text/css" href="/docusaurus.994cfcaae72bb70246f9.css" />

</head>
<body >
<div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a aria-current="page" class="navbar__brand active" href="/"><img class="navbar__logo" src="/img/favicon.png" alt="Flutter-Fans Logo"/><strong>Flutter-Fans</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" label="Blog" position="left" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_1gtMWLzW"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_16vChPFo moon_1N64xB5S"></span></div><div class="react-toggle-track-x"><span class="toggle_16vChPFo sun_3CZP6R61"></span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"/></div></div></div><div role="presentation" class="navbar__sidebar__backdrop"></div><div class="navbar__sidebar"><div class="navbar__sidebar__brand"><a aria-current="page" class="navbar__brand active" href="/"><img class="navbar__logo" src="/img/favicon.png" alt="Flutter-Fans Logo"/><strong>Flutter-Fans</strong></a></div><div class="navbar__sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" label="Blog" position="left" href="/blog">Blog</a></li></ul></div></div></div></nav><div class="container margin-vert--xl"><div class="row"><div class="col col--8 col--offset-2"><div><header><h1 class="margin-bottom--xs"><a aria-current="page" class="active" href="/blog/2019/08/30/flutter-io">Flutter之请求</a></h1><div class="margin-bottom--sm"><small>August<!-- --> <!-- -->30<!-- -->, <!-- -->2019</small></div><div class="avatar margin-bottom--md"><a class="avatar__photo-link" href="https://github.com/MangoTsing" target="_blank" rel="noreferrer noopener"><img class="avatar__photo" src="https://p5.ssl.qhimg.com/t01b6580ec3d65d7b7f.png" alt="MangoTsing"/></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/MangoTsing" target="_blank" rel="noreferrer noopener">MangoTsing</a></h4><small class="avatar__subtitle">A flutter fans</small></div></div></header><article class="markdown"><h2><a aria-hidden="true" class="anchor" id="1网络请求的常见使用"></a><a aria-hidden="true" class="hash-link" href="#1网络请求的常见使用">#</a>1.网络请求的常见使用</h2><h3><a aria-hidden="true" class="anchor" id="1创建http请求"></a><a aria-hidden="true" class="hash-link" href="#1创建http请求">#</a>1.创建http请求</h3><p>http支持位于dart:io，所以要创建一个HTTP client， 我们需要添加一个导入：</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">var httpClient = new HttpClient();</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>该 client 支持常用的HTTP操作, such as GET, POST, PUT, DELETE.</p><h3><a aria-hidden="true" class="anchor" id="2处理异步"></a><a aria-hidden="true" class="hash-link" href="#2处理异步">#</a>2.处理异步</h3><p>HTTP API 在返回值中使用了Dart Futures。 我们建议使用async/await语法来调用API。</p><p>网络调用通常遵循如下步骤：</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">创建 client.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">构造 Uri.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">发起请求, 等待请求，同时您也可以配置请求headers、 body。</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">关闭请求, 等待响应.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">解码响应的内容.</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>其中的几个步骤使用基于<code>Future</code>的API。</p><p>使用 HttpClient 发送请求之前，需要先使用 Uri 构建请求的 Uri 对象。</p><blockquote><p>Uri uri = new Uri.http(&#x27;tj.nineton.cn&#x27;, &#x27;/Heart/index/all&#x27;, {&#x27;city&#x27;: &#x27;CHSH000000&#x27;, &#x27;language&#x27;: &#x27;zh-chs&#x27;});</p></blockquote><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">httpRequestGet() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  HttpClient client = new HttpClient();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var authority = &#x27;tj.nineton.cn&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var unencodedPath = &#x27;/Heart/index/all&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var params = {&#x27;city&#x27;: &#x27;CHSH000000&#x27;, &#x27;language&#x27;: &#x27;zh-chs&#x27;};</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Uri uri = new Uri.http(authority, unencodedPath, params);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var request = await client.getUrl(uri);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var response = await request.close();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  if (response.statusCode == HttpStatus.ok) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    var responseMessage = await response.transform(Utf8Decoder()).join();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    //response.transform(Utf8Decoder()).join()需要导入dart:convert库使用</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    print(responseMessage);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  } else {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    print(response.toString());</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><h3><a aria-hidden="true" class="anchor" id="3解码和编码json"></a><a aria-hidden="true" class="hash-link" href="#3解码和编码json">#</a>3.解码和编码JSON</h3><p>使用<code>dart:convert</code>库可以简单解码和编码JSON。</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">Map data = JSON.decode(responseBody);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">// Assume the response body is something like: [&#x27;foo&#x27;, { &#x27;bar&#x27;: 499 }]</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">int barValue = data[1][&#x27;bar&#x27;]; // barValue is set to 499</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>要对简单的JSON进行编码，请将简单值（字符串，布尔值或数字字面量）或包含简单值的Map，list等传给encode方法：</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">String encodedString = JSON.encode([1, 2, { &#x27;a&#x27;: null }]);</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><h3><a aria-hidden="true" class="anchor" id="4demo"></a><a aria-hidden="true" class="hash-link" href="#4demo">#</a>4.demo</h3><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:convert&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;package:flutter/material.dart&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  runApp(new MyApp());</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">class MyApp extends StatelessWidget {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  @override</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Widget build(BuildContext context) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    return new MaterialApp(</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      home: new MyHomePage(),</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    );</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">class MyHomePage extends StatefulWidget {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  MyHomePage({Key key}) : super(key: key);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  @override</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  _MyHomePageState createState() =&gt; new _MyHomePageState();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">class _MyHomePageState extends State&lt;MyHomePage&gt; {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var _ipAddress = &#x27;Unknown&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  _getIPAddress() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    var url = &#x27;https://httpbin.org/ip&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    var httpClient = new HttpClient();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    String result;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    try {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      var request = await httpClient.getUrl(Uri.parse(url));</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      var response = await request.close();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      if (response.statusCode == HttpStatus.OK) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        var json = await response.transform(utf8.decoder).join();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        var data = jsonDecode(json);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        result = data[&#x27;origin&#x27;];</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      } else {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        result =</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        &#x27;Error getting IP address:\nHttp status ${response.statusCode}&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    } catch (exception) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      result = &#x27;Failed getting IP address&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    // If the widget was removed from the tree while the message was in flight,</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    // we want to discard the reply rather than calling setState to update our</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    // non-existent appearance.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    if (!mounted) return;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    setState(() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      _ipAddress = result;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    });</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  @override</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Widget build(BuildContext context) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    var spacer = new SizedBox(height: 32.0);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    return new Scaffold(</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      body: new Center(</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        child: new Column(</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">          mainAxisAlignment: MainAxisAlignment.center,</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">          children: &lt;Widget&gt;[</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">            new Text(&#x27;Your current IP address is:&#x27;),</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">            new Text(&#x27;$_ipAddress.&#x27;),</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">            spacer,</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">            new RaisedButton(</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">              onPressed: _getIPAddress,</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">              child: new Text(&#x27;Get IP address&#x27;),</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">            ),</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">          ],</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        ),</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      ),</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    );</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><h2><a aria-hidden="true" class="anchor" id="2介绍一下dartio"></a><a aria-hidden="true" class="hash-link" href="#2介绍一下dartio">#</a>2.介绍一下dart:io</h2><p>首先介绍一个在Flutter框架中最常用的一个核心库 <code>dart:io</code></p><blockquote><p>File, socket, HTTP, and other I/O support for non-web applications.</p></blockquote><p>这个库的核心用途如上所述，在文件，socket,http请求，以及为其他的离线应用提供io支持。</p><h3><a aria-hidden="true" class="anchor" id="1dartio核心lib"></a><a aria-hidden="true" class="hash-link" href="#1dartio核心lib">#</a>1.dart:io核心lib</h3><p>但是官网上有一个important提醒：</p><blockquote><p>Browser-based applications can&#x27;t use this library.
Only servers, command-line scripts,
and Flutter mobile apps can import and use dart:io.</p></blockquote><p><code>dart:io</code>这个库可以帮助开发者在服务端，命令行的脚本以及Flutter创造的移动app里通过引用的方式使用，但是不可以在基于浏览器的应用上使用。也就是说在web app上是不适用的。</p><p><strong>但是，这样一个的io core lib 为什么会是Flutter网络请求第一个要介绍的库呢？</strong></p><p>因为官方使用的是用<code>dart:io</code>中的<code>HttpClient</code>类发起的请求，但HttpClient本身功能较弱，很多常用功能都不支持。</p><blockquote><p>The dart:io library is aimed at code that runs
in Flutter and the standalone Dart VM.</p></blockquote><p><code>dart:io</code>库的目标是在Flutter和独立的Dart VM中运行的代码</p><blockquote><p>Note: When writing a Flutter app,
use Flutter-specific APIs instead of dart:io whenever possible.
For example, use the Flutter asset support to
load images and other assets into your app.</p></blockquote><p>官网上也给了个提示，就是说我们在使用dart:io库的时候要注意，写一个app时尽可能的使用flutter所提供的专属API，而不要在任何时候都适用dart:io库，比如可以使用Flutter asset来加载图像</p><p><strong>Dart是一种单线程编程语言。 如果操作阻止Dart线程，则应用程序在该操作完成之前不会进行任何操作。 因此，为了可扩展性，没有I / O操作阻塞是至关重要的。 dart：io使用受node.js， EventMachine和Twisted启发的异步编程模型，而不是阻止I / O操作。</strong></p><blockquote><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">EventMachine是一個軟件系統，旨在為Ruby編寫高度可伸縮的應用程序。它使用reactor模式提供事件驅動的I / O. EventMachine是Ruby編程語言中最受歡迎的並發計算庫。</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Twisted 是一个事件驱动的网络编程框架，它使用编程语言Python编写，并在MIT协议下开源。</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">（reactor:     reactor设计模式，是一种基于事件驱动的设计模式。Reactor框架是ACE各个框架中最基础的一个框架，其他框架都或多或少地用到了Reactor框架。</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">在事件驱动的应用中，将一个或多个客户的服务请求分离（demultiplex）和调度（dispatch）给应用程序。在事件驱动的应用中，同步地、有序地处理同时接收的多个服务请求。 reactor模式与外观模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。当一个主体发生改变时，所有依属体都得到通知。）</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">EventMachine is a software system designed for writing highly scalable applications for Ruby. It provides event-driven I/O using the reactor pattern.</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre></blockquote><h3><a aria-hidden="true" class="anchor" id="2dart-vm和事件循环"></a><a aria-hidden="true" class="hash-link" href="#2dart-vm和事件循环">#</a>2.Dart VM和事件循环</h3><p>在深入研究异步i/o操作之前，解释一下dart vm的单线程是很有必要的。</p><p>执行服务器端应用程序时，Dart VM在事件循环中运行，Timer函数作为一个异步的函数等待挂起，处于<code>pending</code>状态，单线程的处理机制很类似javascript。</p><p>尽管当代码输出<code>end of main</code>时，整个dart VM依然没有终止运行，因为Timer继续处于挂起的状态，等待<code>timer</code>输出完毕后，终止执行。当确定整个程序都已经没有挂起的操作，在这个执行队列里时，dart vm停止。</p><p><strong>代码如下：</strong></p><p>  	import &#x27;dart:async&#x27;;</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Timer(Duration(seconds: 1), () =&gt; print(&#x27;timer&#x27;));</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  print(&#x27;end of main&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>在命令行运行此示例，我们得到：</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">$ dart timer.dart </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    end of main </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    timer</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>可以使用构造函数<code>Timer.periodic</code>重复计时器，VM将不会终止并继续每秒打印出&#x27;timer&#x27;。</p><p>类似javascript 的 setInterval</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Timer.periodic(Duration(seconds: 2), (Timer timer){</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    print(&#x27;timer&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    timer.cancel();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  } );</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><h3><a aria-hidden="true" class="anchor" id="3dart文件访问"></a><a aria-hidden="true" class="hash-link" href="#3dart文件访问">#</a>3.dart文件访问</h3><p>dart：io库通过File和Directory类提供对文件和目录的访问。</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">var myFile = new File(&#x27;file.txt&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:convert&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:async&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">main() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final file = new File(&#x27;file.txt&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Stream&lt;List&lt;int&gt;&gt; inputStream = file.openRead();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  inputStream</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    .transform(utf8.decoder)       // Decode bytes to UTF-8.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    .transform(new LineSplitter()) // Convert stream to individual lines.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    .listen((String line) {        // Process results.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        print(&#x27;$line: ${line.length} bytes&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      },</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      onDone: () { print(&#x27;File is now closed.&#x27;); },</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      onError: (e) { print(e.toString()); });</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">下面是目录：</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">var myDir = new Directory(&#x27;myDir&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // Creates dir/ and dir/subdir/.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  new Directory(&#x27;dir/subdir&#x27;).create(recursive: true)</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    // The created directory is returned as a Future.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    .then((Directory directory) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      print(directory.path);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  });</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>我们使用<code>Platform</code>类，来打印一份本地的脚本源码：</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import&#x27;dart：convert&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain"> import&#x27;dart：io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain"> Future &lt;void&gt; main（）async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">   var file = File（Platform.script.toFilePath（））;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">   print（“$ {await（file.readAsString（encoding：ascii））}”）;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain"> }</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p> <code>readAsString()</code>方法是异步的, 它返回一个Future对象 ，一旦从底层系统读取文件，它就会返回文件的内容。 由于异步，可以在执行的过程中进行其他操作。</p><p>为了清晰的解释文件操作，让我们更改示例以仅读取内容直到第一个分号，然后打印它。 </p><p>可以使用<code>Stream</code></p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; main() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final semicolon = &#x27;;&#x27;.codeUnitAt(0);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var result = &lt;int&gt;[];</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final script = File(Platform.script.toFilePath());</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  RandomAccessFile file = await script.open(mode: FileMode.read);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // Deal with each byte.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  while (true) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    final byte = await file.readByte();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    result.add(byte);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    if (byte == semicolon) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      print(String.fromCharCodes(result));</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      await file.close();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      break;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>当看到<code>async</code>或<code>await</code> ，可以确定使用了Future对象。 open()和readByte()方法都返回一个Future对象。</p><p>当然，这段代码是随机访问操作的一种非常简单的用法。 操作可用于写入，寻找给定位置，截断等等。</p><p>让我们使用Stream实现一个版本。 以下代码打开用于读取的文件，将内容显示为字节列表流。 像Dart中的所有流一样，可以对Stream使用await for监听，数据以<code>chunks</code>的形式给出。</p><blockquote><p>, 39, 46, 111, 109, 67, 104, 97, 114, 67, 111, 100, 101, 115, 40, 114, 101, 115, 117, 108, 116, 41, 41, 59, 10, 32, 32, 32, 32, 32, 32, 32, 32, 114, 101, 116, 117, 114, 110, 59, 10, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 32, 32, 125, 10, 125]</p></blockquote><p>  	import &#x27;dart:io&#x27;;</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; main() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var result = &lt;int&gt;[];</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Stream&lt;List&lt;int&gt;&gt; stream = File(Platform.script.toFilePath()).openRead();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final semicolon = &#x27;;&#x27;.codeUnitAt(0);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  await for (var data in stream) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    for (int i = 0; i &lt; data.length; i++) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      result.add(data[i]);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      if (data[i] == semicolon) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        print(String.fromCharCodes(result));</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        return;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>Stream通过awiat for循环监听，监听到<code>；</code>的code时，就会输出当前获取到的result。并且await for通过break,return,异常捕获可以退出循环监听。</p><p><code>Stream&lt;List&lt;int&gt;&gt;</code>在dart:io中习惯被用在很多地方，比如stdin，文件，socket，HTTP连接等时。 同样， <code>IOSink</code>对象用于将数据流式传输到stdout，文件，socket，HTTP连接等。</p><h3><a aria-hidden="true" class="anchor" id="4交互式进程"></a><a aria-hidden="true" class="hash-link" href="#4交互式进程">#</a>4.交互式进程</h3><p>对于简单的情况，可以使用<code>Process.run（）</code>来运行进程并收集其结果。 当不需要对进程进行交互式控制时，请使用run() 。</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; main() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  ProcessResult results = await Process.run(&#x27;ls&#x27;, [&#x27;-l&#x27;]);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  print(results.stdout);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">result:total 16</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">-rw-r--r--  1 shangguanyanpeng  staff     4 Aug 29 15:22 file.txt</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">-rw-r--r--  1 shangguanyanpeng  staff  2556 Aug 29 16:09 main.dart</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p><strong>还可以使用Process.start（）创建Process对象来启动进程。</strong></p><p>一旦有了Process对象，就可以通过将数据写入stdin接收器，从stderr和stdout流中读取数据并终止进程来与进程交互。 当进程退出时， exitCode将来会以进程的退出代码完成。(输出输出流)</p><p>下面代码在单独的进程中运行<code>ls -l</code> ，并将进程的输出和退出代码输出到<code>stdout</code>。 由于我们希望获取行，因此我们使用Utf8Decoder （将字节块解码为字符串），然后使用LineSplitter （在行边界处拆分字符串）。</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:convert&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; main() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final process = await Process.start(&#x27;ls&#x27;, [&#x27;-l&#x27;]);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var lineStream =</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      process.stdout.transform(Utf8Decoder()).transform(LineSplitter());</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  await for (var line in lineStream) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    print(line);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  await process.stderr.drain();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  print(&#x27;exit code: ${await process.exitCode}&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p><code>exitCode</code>可以在处理完所有输出行之前完成。 另外没有定义进程关闭， 为了不泄漏资源，我们必须同时监听<code>stderr</code>和<code>stdout</code>流。 我们使用await for来监听stdout，并使用stderr.drain()来监听（并释放）stderr。</p><p>我们也可以输出给文件，而不是将输出打印到stdout。</p><p> 	import &#x27;dart:io&#x27;;</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; main() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final output = File(&#x27;output.txt&#x27;).openWrite();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Process process = await Process.start(&#x27;ls&#x27;, [&#x27;-l&#x27;]);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // Wait for the process to finish; get the exit code.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final exitCode = (await Future.wait([</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    process.stdout.pipe(output), // Send stdout to file.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    process.stderr.drain(), // Discard stderr.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    process.exitCode</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  ]))[2];</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  print(&#x27;exit code: $exitCode&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><h3><a aria-hidden="true" class="anchor" id="5编写web服务器"></a><a aria-hidden="true" class="hash-link" href="#5编写web服务器">#</a>5.编写Web服务器</h3><p><code>dart：io</code>可以轻松编写HTTP服务器和客户端。 要编写一个简单的Web服务器，您所要做的就是创建一个<code>HttpServer</code>并将一个监听器（使用await for ）连接到它的HttpRequest流。</p><p>这是一个简单的Web服务器，可以回答任何请求的“Hello，world”。</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; main() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final server = await HttpServer.bind(&#x27;127.0.0.1&#x27;, 8082);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  await for (HttpRequest request in server) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    request.response.write(&#x27;Hello, world&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    await request.response.close();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>运行此应用程序并将浏览器指向“<a href="http://127.0.0.1:8082%E2%80%9D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AAHello">http://127.0.0.1:8082”，可以得到一个Hello</a> world的字符串展示。</p><p>接下来增加代码，如果请求中未指定路径，将展示index.html。对于带路径的请求，我们将尝试查找文件并提供服务。 如果找不到该文件，我们将回复“未找到404”状态。</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:io&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; runServer(String basePath) async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final server = await HttpServer.bind(&#x27;127.0.0.1&#x27;, 8082);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  await for (HttpRequest request in server) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    await handleRequest(basePath, request);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; handleRequest(String basePath, HttpRequest request) async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final String path = request.uri.toFilePath();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // PENDING: Do more security checks here.</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final String resultPath = path == &#x27;/&#x27; ? &#x27;/index.html&#x27; : path;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final File file = File(&#x27;$basePath$resultPath&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  if (await file.exists()) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    try {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      await request.response.addStream(file.openRead());</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    } catch (exception) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      print(&#x27;Error happened: $exception&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      await sendInternalError(request.response);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  } else {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    await sendNotFound(request.response);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; sendInternalError(HttpResponse response) async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  response.statusCode = HttpStatus.internalServerError;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  await response.close();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; sendNotFound(HttpResponse response) async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  response.statusCode = HttpStatus.notFound;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  await response.close();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;void&gt; main() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // Compute base path for the request based on the location of the</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // script, and then start the server.![]()</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final script = File(Platform.script.toFilePath());</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  await runServer(script.parent.path);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>编写HTTP客户端与使用HttpClient类非常相似。</p><p>所以接下来就来了解一下，神奇的<code>HttpClient</code> class!</p><h2><a aria-hidden="true" class="anchor" id="3神奇的httpclient"></a><a aria-hidden="true" class="hash-link" href="#3神奇的httpclient">#</a>3.神奇的HttpClient</h2><blockquote><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">`HttpClient`是Dart SDK中提供的标准的访问网络的接口类，是`HTTP1.1/RFC2616`协议在Dart SDK上的具体实现，用于客户端发送HTTP/S 请求。HttpClient 包含了一组方法，可以发送 HttpClientRequest 到Http服务器， 并接收 HttpClientResponse 作为服务器的响应。 例如, 我们可以用 get, getUrl, post, 和 postUrl 方法分别发送 GET 和 POST 请求。</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre></blockquote><p>下面是一段简单的代码：</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import &quot;dart:io&quot;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;dart:convert&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">void main() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var baidu = &quot;http://www.baidu.com&quot;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var httpClient = HttpClient();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  HttpClientRequest request = await httpClient.getUrl(Uri.parse(baidu));</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  HttpClientResponse response = await request.close();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var responseBody = await response.transform(Utf8Decoder()).join();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  httpClient.close();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  print(responseBody);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><h3><a aria-hidden="true" class="anchor" id="1基本实现"></a><a aria-hidden="true" class="hash-link" href="#1基本实现">#</a>1.基本实现</h3><p>HttpClient 及相关模块实际上实现的是TCP/IP的Http协议栈。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca7aff7bcc9356?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"/></p><p> 模块对上层应用暴露的接口就是HttpClient，客户端可以通过API发起Http请求并接收Http响应。 </p><p> 模块下层依赖的是TCP协议栈，从代码实现上而言就是依赖Socket/SecureSocket，因为在操作系统上Sockt封装了TCP/IP的所有操作，便于上层协议处理。</p><p> <strong>顶层流程分析：Step 1: HttpClient getUrl 获取 HttpClientRequest的过程：这个过程实质上是sockt建立TCP链接的过程：sockt需要通过DNS解析把域名转换为ip地址然后通过TCP的三次握手，建立socket链接，Dart中用HttpClientConnection保存这个链接。构建一个HttpClientRequest对象，并返回客户端。客户端可以在这个对象中添加更多应用相关的Http包头字段，等待发送。注意到这个过程仅仅是建立socket链路，并没有实际发送数据。Step 2: HttpClientRequest.close 表明HttpClientRequest已经构建完成，socket发送Http请求。收到响应后返回给客户端。Step 3: HttpClientRsponse被消费后，HttpClient关闭链接。socket发送TCP四次挥手信息，关闭传输，并释放所有资源。</strong></p><h3><a aria-hidden="true" class="anchor" id="2httpclient"></a><a aria-hidden="true" class="hash-link" href="#2httpclient">#</a>2.HttpClient</h3><p> 作为library暴露的API，定义在/dart-sdk/lib/_http/http.dart，通过工厂方法调用实现类_HttpClient; 所以HttpClient.getUrl 调用的是 _HttpClient.getUrl;</p><h3><a aria-hidden="true" class="anchor" id="3_httpclient"></a><a aria-hidden="true" class="hash-link" href="#3_httpclient">#</a>3._HttpClient</h3><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">Future&lt;HttpClientRequest&gt; openUrl(String method, Uri url) =&gt; _openUrl(method, url);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; get(String host, int port, String path) =&gt; open(&quot;get&quot;, host, port, path);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; getUrl(Uri url) =&gt; _openUrl(&quot;get&quot;, url);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; post(String host, int port, String path) =&gt; open(&quot;post&quot;, host, port, path);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; postUrl(Uri url) =&gt; _openUrl(&quot;post&quot;, url);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; put(String host, int port, String path) =&gt; open(&quot;put&quot;, host, port, path);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; putUrl(Uri url) =&gt; _openUrl(&quot;put&quot;, url);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; delete(String host, int port, String path) =&gt;open(&quot;delete&quot;, host, port, path);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; deleteUrl(Uri url) =&gt; _openUrl(&quot;delete&quot;, url);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; head(String host, int port, String path) =&gt; open(&quot;head&quot;, host, port, path);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; headUrl(Uri url) =&gt; _openUrl(&quot;head&quot;, url);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; patch(String host, int port, String path) =&gt; open(&quot;patch&quot;, host, port, path);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Future&lt;HttpClientRequest&gt; patchUrl(Uri url) =&gt; _openUrl(&quot;patch&quot;, url);</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>API 封装了常用的get，post，put，delete，head，patch等方法，统一由_HttpClient._openUrl 处理</p><h3><a aria-hidden="true" class="anchor" id="4-httpclientrequestclose"></a><a aria-hidden="true" class="hash-link" href="#4-httpclientrequestclose">#</a>4. HttpClientRequest.close</h3><p>openUrl两个工作：建立链接，获取HttpClientRequest对象:</p><p><img src="http://p0.qhimg.com/t01520cce774751b9b8.png"/></p><h3><a aria-hidden="true" class="anchor" id="5httpclientclose"></a><a aria-hidden="true" class="hash-link" href="#5httpclientclose">#</a>5.HttpClient.close</h3><p>此流程比较简单，最终调用socket的close，TCP四次挥手断开链接。这里就不展开了。需要指出的是，如果不主动调用HttpClient.close，socket不会立即释放，链接会保留一段时间超时退出，因此存在资源泄漏的风险。</p><h2><a aria-hidden="true" class="anchor" id="4衍生出的网络请求框架"></a><a aria-hidden="true" class="hash-link" href="#4衍生出的网络请求框架">#</a>4.衍生出的网络请求框架</h2><h3><a aria-hidden="true" class="anchor" id="1http框架"></a><a aria-hidden="true" class="hash-link" href="#1http框架">#</a>1.http框架</h3><h4><a aria-hidden="true" class="anchor" id="using"></a><a aria-hidden="true" class="hash-link" href="#using">#</a>Using</h4><p>The easiest way to use this library is via the top-level functions. They allow you to make individual HTTP requests with minimal hassle:</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;package:http/http.dart&#x27; as http;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">var url = &#x27;http://example.com/whatsit/create&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">var response = await http.post(url, body: {&#x27;name&#x27;: &#x27;doodle&#x27;, &#x27;color&#x27;: &#x27;blue&#x27;});</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">print(&#x27;Response status: ${response.statusCode}&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">print(&#x27;Response body: ${response.body}&#x27;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">print(await http.read(&#x27;http://example.com/foobar.txt&#x27;));</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>If you&#x27;re making multiple requests to the same server, you can keep open a persistent connection by using a Client rather than making one-off requests. If you do this, make sure to close the client when you&#x27;re done:</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">var client = new http.Client();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">try {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  var uriResponse = await client.post(&#x27;http://example.com/whatsit/create&#x27;,</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      body: {&#x27;name&#x27;: &#x27;doodle&#x27;, &#x27;color&#x27;: &#x27;blue&#x27;});</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  print(await client.get(uriResponse.bodyFields[&#x27;uri&#x27;]));</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">} finally {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  client.close();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>You can also exert more fine-grained control over your requests and responses by creating Request or StreamedRequest objects yourself and passing them to Client.send.</p><p>This package is designed to be composable. This makes it easy for external libraries to work with one another to add behavior to it. Libraries wishing to add behavior should create a subclass of BaseClient that wraps another Client and adds the desired behavior:</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">class UserAgentClient extends http.BaseClient {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final String userAgent;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  final http.Client _inner;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  UserAgentClient(this.userAgent, this._inner);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Future&lt;StreamedResponse&gt; send(BaseRequest request) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    request.headers[&#x27;user-agent&#x27;] = userAgent;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    return _inner.send(request);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><h3><a aria-hidden="true" class="anchor" id="2强大的flutter-http请求开源库-dio"></a><a aria-hidden="true" class="hash-link" href="#2强大的flutter-http请求开源库-dio">#</a>2.强大的Flutter Http请求开源库-dio</h3><p>FormData,错误处理,Lock/unlock 拦截器,转换器,设置Http代理,请求取消,Cookie管理</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">dependencies:</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  dio: ^x.x.x  // latest version</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">import &#x27;package:dio/dio.dart&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Dio dio = new Dio();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">Response response=await dio.get(&quot;https://www.google.com/&quot;);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">print(response.data);</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>通过对HTTPCLIENT类的封装，可以简单的处理请求到的数据，不需要再用dart convert进行编码处理，同时可以发送FormData包，对一些数据进行拦截处理，预处理一些格式等等。</p><blockquote><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">参考文献：</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">https://dart.dev/guides/libraries/library-tour#dartio</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">https://dart.dev/articles/libraries/dart-io</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">https://www.jianshu.com/p/91c2511d104f</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">https://juejin.im/post/5d5a0733f265da03cc08ba4b#heading-15</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">https://api.dart.dev/stable/2.4.1/dart-io/</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre></blockquote></article><div class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/flutter">flutter</a><a class="margin-horiz--sm" href="/blog/tags/io">io</a></div><div class="col text--right"></div></div></div><div class="margin-vert--xl"><nav class="pagination-nav"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2019/10/11/flutter-hybrid-explain"><h5 class="pagination-nav__link--sublabel">Previous Post</h5><h4 class="pagination-nav__link--label">« <!-- -->Flutter 混合栈复用原理</h4></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2019/08/29/flutter-layout-and-paint"><h5 class="pagination-nav__link--sublabel">Next Post</h5><h4 class="pagination-nav__link--label">Flutter的布局和绘制<!-- --> »</h4></a></div></nav></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="text--center">Copyright © 2019 Flutter-Fans. Built with Docusaurus.</div></div></footer>
</div>

<script type="text/javascript" src="/runtime~main.1e8341a32f645e7b2fe7.js"></script>

<script type="text/javascript" src="/main.cce358011c7da27efa46.js"></script>

<script type="text/javascript" src="/vendors.20ec14ef348a891cbe0a.js"></script>

<script type="text/javascript" src="/react-helmet.7bf7b3bdf6ce28021eb7.js"></script>

<script type="text/javascript" src="/prism-react-renderer.e76e6ef8997e15114c2f.js"></script>

<script type="text/javascript" src="/component---users-wangjianbing-project-fluttercn-dev-src-pages-index-js-8-f-8-fe8.d15de7da6ae110ab3e0a.js"></script>

<script type="text/javascript" src="/docusaurus.994cfcaae72bb70246f9.js"></script>

<script type="text/javascript" src="/content---blog-2019-08-30-flutter-io-633-c2e.2afd21e6c6b6ff67737c.js"></script>

<script type="text/javascript" src="/nextItem---blog-2019-10-11-flutter-hybrid-explain-883-5d4.636727ecc735dfbf83ec.js"></script>

<script type="text/javascript" src="/metadata---blog-2019-10-11-flutter-hybrid-explain-680-3e4.51a2a7478739c093e7d6.js"></script>

<script type="text/javascript" src="/nextItem---blog-2019-08-30-flutter-io-5-a-1-61e.106c7db7d1aa7fce6d74.js"></script>

</body>
</html>