<!DOCTYPE html>
<html lang=&#34;en&#34; data-theme=&#34;&#34;>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script type="text/javascript">/*<![CDATA[*/window.__chunkMapping={"main":["/main.c96f282b900a0b52042c.css","/main.c96f282b900a0b52042c.js"],"component---users-zhaoyan-documents-project-fluttercn-dev-src-pages-index-js-85-a-818":["/component---users-zhaoyan-documents-project-fluttercn-dev-src-pages-index-js-85-a-818.4945fdd399e2e4cd3638.css","/component---users-zhaoyan-documents-project-fluttercn-dev-src-pages-index-js-85-a-818.4945fdd399e2e4cd3638.js"],"metadata---fd-8-5f3":["/metadata---fd-8-5f3.5afc354b757ed75e02c0.js"],"component---theme-blog-post-pageccc-cab":[],"content---blog-2019-08-14-flutter-platform-channel-245-7ae":["/content---blog-2019-08-14-flutter-platform-channel-245-7ae.422de328a218d9414da6.js"],"metadata---blog-2019-08-14-flutter-platform-channel-8-ef-2e2":["/metadata---blog-2019-08-14-flutter-platform-channel-8-ef-2e2.48be2e8936c6bae9c063.js"],"nextItem---blog-2019-08-14-flutter-platform-channel-72-f-689":["/nextItem---blog-2019-08-14-flutter-platform-channel-72-f-689.36393d7d44adf2a27924.js"],"content---blog-2019-08-11-flutter-rendercc-3-7dd":["/content---blog-2019-08-11-flutter-rendercc-3-7dd.9c618974b67616ee0108.js"],"nextItem---blog-2019-08-11-flutter-render-1-b-0-118":["/nextItem---blog-2019-08-11-flutter-render-1-b-0-118.a67d4c5a2d14092242f7.js"],"content---blog-2019-08-09-flutter-platform-view-681-1e6":["/content---blog-2019-08-09-flutter-platform-view-681-1e6.c826fd7e5325017ce8ae.js"],"nextItem---blog-2019-08-09-flutter-platform-viewc-00-0b8":["/nextItem---blog-2019-08-09-flutter-platform-viewc-00-0b8.305da2bdd7de4bcf04ee.js"],"content---blog-2019-07-29-flutter-image-7-ce-0ee":["/content---blog-2019-07-29-flutter-image-7-ce-0ee.7acac2eff8966331ad1c.js"],"nextItem---blog-2019-07-29-flutter-image-018-dd6":["/nextItem---blog-2019-07-29-flutter-image-018-dd6.7966bbc5850fa453fa70.js"],"content---blog-2019-07-23-flutter-text-823-fb9":["/content---blog-2019-07-23-flutter-text-823-fb9.fa7dd0f2ceafb78e63f8.js"],"nextItem---blog-2019-07-23-flutter-textc-01-5e3":["/nextItem---blog-2019-07-23-flutter-textc-01-5e3.7e46d2660ad687ce4b64.js"],"content---blog-2019-07-16-dart-basis-4-ff-3-b58":["/content---blog-2019-07-16-dart-basis-4-ff-3-b58.d98c5ba60f3518f9baf2.js"],"nextItem---blog-2019-07-16-dart-basis-460-a-740":["/nextItem---blog-2019-07-16-dart-basis-460-a-740.cd167e46e20300935896.js"],"content---blog-2019-07-15-dart-basis-327-c-47d":["/content---blog-2019-07-15-dart-basis-327-c-47d.c05062c0a05ff3ee4118.js"],"nextItem---blog-2019-07-15-dart-basis-3693-6a6":["/nextItem---blog-2019-07-15-dart-basis-3693-6a6.e226dd9e0a66efb25839.js"],"content---blog-2019-07-14-dart-basis-20-d-2-195":["/content---blog-2019-07-14-dart-basis-20-d-2-195.3c1cef2a82f7141cb915.js"],"nextItem---blog-2019-07-14-dart-basis-23-f-7-349":["/nextItem---blog-2019-07-14-dart-basis-23-f-7-349.39ca72f55dc8ff9ea4d8.js"],"content---blog-2019-07-13-dart-basis-1337-367":["/content---blog-2019-07-13-dart-basis-1337-367.b7e68aa5c096266a875b.js"],"nextItem---blog-2019-07-13-dart-basis-15-b-8-ccc":["/nextItem---blog-2019-07-13-dart-basis-15-b-8-ccc.0c3c1fef1239ec93e016.js"],"content---blog-2019-07-12-flutter-widget-videosb-80-447":["/content---blog-2019-07-12-flutter-widget-videosb-80-447.53848ae015081cd1e750.js"],"component---theme-doc-legacy-page-9-e-7-ca5":[],"docsMetadata---docs-7-f-7-bea":["/docsMetadata---docs-7-f-7-bea.5454495baf8d44a46b95.js"],"component---theme-doc-legacy-item-031-769":[],"content---docs-doc-1485-ea9":["/content---docs-doc-1485-ea9.91a21120b62deaa378a9.js"],"metadata---docs-doc-1938-69f":["/metadata---docs-doc-1938-69f.d0d14fb35db6e65d774c.js"],"content---docs-doc-23-da-2dd":["/content---docs-doc-23-da-2dd.74ded79c1db0d94cf327.js"],"metadata---docs-doc-203-b-f35":["/metadata---docs-doc-203-b-f35.13716f117b9af435092c.js"],"content---docs-doc-38-b-3-af8":["/content---docs-doc-38-b-3-af8.ad4df2a5aa083e103a8a.js"],"metadata---docs-doc-3-f-8-f-df4":["/metadata---docs-doc-3-f-8-f-df4.e4d8d0854ec66ec94fdc.js"],"content---docs-mdx-0-bf-16e":["/content---docs-mdx-0-bf-16e.3e02d3758d1e727a3b92.js"],"metadata---docs-mdx-96-d-0f3":["/metadata---docs-mdx-96-d-0f3.984c5c2ec701793d14ed.js"],"component---theme-blog-list-pagea-6-a-7ba":[],"content---blog-931-68c":["/content---blog-931-68c.d381a15cfdf2f8b4b27b.js"],"content---blogabb-fcf":["/content---blogabb-fcf.86570279aa281ca9814c.js"],"content---blog-46-c-a0c":["/content---blog-46-c-a0c.a9492727a63bf3db64a1.js"],"content---blog-063-c18":["/content---blog-063-c18.fa065d9d66e1f230a709.js"],"content---blogb-3-a-97e":["/content---blogb-3-a-97e.282155ac79d643b972b0.js"],"content---blogf-92-898":["/content---blogf-92-898.27ae9b412791ffefd4cd.js"],"content---blog-84-f-da8":["/content---blog-84-f-da8.ca2fddf3ae1025faff64.js"],"content---blog-536-6e8":["/content---blog-536-6e8.faa4b76d93a6a4176f86.js"],"content---blogb-00-8ad":["/content---blogb-00-8ad.903297a81cec3b7f5ff8.js"],"content---blog-5-fc-b56":["/content---blog-5-fc-b56.ac520e3c8937dc1e440e.js"],"metadata---blog-042-006":["/metadata---blog-042-006.8a79ab629010cc3232dd.js"],"component---theme-blog-tags-posts-page-687-b6c":[],"metadata---blog-tags-flutterdd-5-77c":["/metadata---blog-tags-flutterdd-5-77c.ab38a18272a314cea6f3.js"],"metadata---blog-tags-platform-view-400-357":["/metadata---blog-tags-platform-view-400-357.7fe26a61135d953d96b1.js"],"metadata---blog-tags-widget-927-27f":["/metadata---blog-tags-widget-927-27f.902439de6db73ecced82.js"],"metadata---blog-tags-dart-59-e-f7a":["/metadata---blog-tags-dart-59-e-f7a.2f8ad5cb6a60cb8cb2a6.js"],"metadata---blog-tags-basic-03-d-932":["/metadata---blog-tags-basic-03-d-932.fa56c7cac3d05d91fe45.js"],"metadata---blog-tags-videoc-18-4f1":["/metadata---blog-tags-videoc-18-4f1.469d855d5e790e8d9308.js"],"component---theme-blog-tags-list-page-01-a-d0b":[],"tags---blog-tagsac-5-ed9":["/tags---blog-tagsac-5-ed9.6e28d213d5e2d6574e43.js"]};/*]]>*/</script>

<title data-react-helmet="true">Flutter 从加载到显示</title>

<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="viewport" content="width=device-width"/><meta data-react-helmet="true" property="og:title" content="Flutter 从加载到显示"/><meta data-react-helmet="true" name="description" content="## 你将会得到什么？"/><meta data-react-helmet="true" property="og:description" content="## 你将会得到什么？"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/>

<link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"/>


<link rel="stylesheet" type="text/css" href="/main.c96f282b900a0b52042c.css" />

<link rel="stylesheet" type="text/css" href="/component---users-zhaoyan-documents-project-fluttercn-dev-src-pages-index-js-85-a-818.4945fdd399e2e4cd3638.css" />

<link rel="stylesheet" type="text/css" href="/docusaurus.c6059712e04a5824f5a6.css" />

</head>
<body >
<div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a aria-current="page" class="navbar__brand active" href="/"><img class="navbar__logo" src="/img/favicon.png" alt="Flutter-Fans Logo"/><strong>Flutter-Fans</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" label="Blog" position="left" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_1gtMWLzW"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_16vChPFo moon_1N64xB5S"></span></div><div class="react-toggle-track-x"><span class="toggle_16vChPFo sun_3CZP6R61"></span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"/></div></div></div><div role="presentation" class="navbar__sidebar__backdrop"></div><div class="navbar__sidebar"><div class="navbar__sidebar__brand"><a aria-current="page" class="navbar__brand active" href="/"><img class="navbar__logo" src="/img/favicon.png" alt="Flutter-Fans Logo"/><strong>Flutter-Fans</strong></a></div><div class="navbar__sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" label="Blog" position="left" href="/blog">Blog</a></li></ul></div></div></div></nav><div class="container margin-vert--xl"><div class="row"><div class="col col--8 col--offset-2"><div><header><h1 class="margin-bottom--xs"><a aria-current="page" class="active" href="/blog/2019/08/11/flutter-render">Flutter 从加载到显示</a></h1><div class="margin-bottom--sm"><small>August<!-- --> <!-- -->11<!-- -->, <!-- -->2019</small></div><div class="avatar margin-bottom--md"><a class="avatar__photo-link" href="https://github.com/donald99" target="_blank" rel="noreferrer noopener"><img class="avatar__photo" src="https://avatars2.githubusercontent.com/u/5173695?s=460&amp;v=4" alt="donald99"/></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/donald99" target="_blank" rel="noreferrer noopener">donald99</a></h4><small class="avatar__subtitle">A flutter fans</small></div></div></header><article class="markdown"><h2><a aria-hidden="true" class="anchor" id="你将会得到什么？"></a><a aria-hidden="true" class="hash-link" href="#你将会得到什么？">#</a>你将会得到什么？</h2><p>1、Widget、Element、RenderObject基本概念</p><p>2、在Flutter Framework层从创建到渲染的流程</p><p>3、Flutter在构建布局方面是如何提高效率的</p><h2><a aria-hidden="true" class="anchor" id="什么是flutter？"></a><a aria-hidden="true" class="hash-link" href="#什么是flutter？">#</a>什么是Flutter？</h2><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。它也是构建未来的Google Fuchsia 应用的主要方式。</p><h2><a aria-hidden="true" class="anchor" id="框架结构"></a><a aria-hidden="true" class="hash-link" href="#框架结构">#</a>框架结构</h2><p>Flutter的主要结构包括：</p><ul><li><p>Flutter engine</p></li><li><p>Flutter framework</p><p>我们看一下这个形象又生动的架构图片：</p></li></ul><p><img src="https://p0.ssl.qhimg.com/t01112f5d526c5a0a0a.png" alt="Flutter"/></p><h5><a aria-hidden="true" class="anchor" id="framework层"></a><a aria-hidden="true" class="hash-link" href="#framework层">#</a>Framework层</h5><p>我们来看一下有关部分：
Material   是谷歌UI设计规范、Cupertino 是苹果UI设计规范，我们日常开发经常用这两部分。
Widgets 应用程序用户界面的基本组件，也就是我们开发者在UI开发时着重要处理的部分，官方给到解释是描述Element的配置。
Rendering 抽象布局层，这一层帮助我们完成渲染的初步工作，比如UI元素的位置、大小、绘制等等。
Animation、Painting、Gestures，在代码里面对应的是Dart:UI包，属于底层UI库，主要提供动画、绘制、手势功能。
Foundation    基础工具库</p><p>​        以上就是Framework层，这一层也正是Flutter精髓所在。</p><h5><a aria-hidden="true" class="anchor" id="engine层"></a><a aria-hidden="true" class="hash-link" href="#engine层">#</a>Engine层</h5><p>Skia是2D图像渲染引擎、Dart运行时，Text文字处理引擎。</p><p>这个架构图中开发者着重关注Widget开发工作、Material与Cupertino的使用，其他不需要太关心，这些Flutter团队已经帮普通开发者完成了，但是如果稍作了解，对我们对开发还是有很大帮助的。</p><p>接下来我们一起开始源码分析之旅吧^^</p><p><img src="https://p3.ssl.qhimg.com/t01cd78b2cb2616a7d1.png"/></p><p>这样的页面Flutter Framework是如何处理的？</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">void main() =&gt; runApp(MyApp());</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">class MyApp extends StatelessWidget {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // 这个widget是应用程序的根 </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  @override</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Widget build(BuildContext context) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    return MaterialApp(</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      home: MyHomePage(title: &#x27;Hello 360&#x27;),</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    );</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>我们可以看到在main方法处，调用了runApp方法，这就是Flutter开始加载渲染的入口了。值得我们注意，调用runApp(MyApp())，一般Flutter启动时调用，之后就不再会调用了。这里的MyApp()，就是开发者自定义的rootWidget，即widget的根。也就是这里extends StatelessWidget组件。</p><h2><a aria-hidden="true" class="anchor" id="简单的公式描述"></a><a aria-hidden="true" class="hash-link" href="#简单的公式描述">#</a>简单的公式描述</h2><p>我们知道Flutter的实现有Flutter Framwork 和 Engine两大部分组成，不言而喻，从加载到显示地整个渲染流程极其复杂。从进入runApp方法开始到屏幕上显示出来这个过程，我们可否用一个简单的方程式来简单描述一下呢？</p><p><img src="https://p5.ssl.qhimg.com/t0104ac3c04c244b5fe.png"/></p><p>1、state就是我们Application内的那些逻辑和内部状态;
2、f() 表示用来描述用户界面部分的方法，比如：build方法调用；
3、UI 屏幕上显示的布局视图；</p><p>这个方程式很形象生动的描述了这个state变化到UI渲染完成显示的过程。</p><h2><a aria-hidden="true" class="anchor" id="widget"></a><a aria-hidden="true" class="hash-link" href="#widget">#</a>Widget</h2><p>Widget ：小部件，也就是我们开发者在UI开发时着重要处理的部分，官方给到解释是：描述Element的配置信息，属于不可变对象，它的属性是final修饰。</p><h2><a aria-hidden="true" class="anchor" id="buildcontext"></a><a aria-hidden="true" class="hash-link" href="#buildcontext">#</a>BuildContext</h2><p>用来获取上下文的数据，它实际就是Element，BuildContext是为了开发者不直接操作Element而抽象出来的类，所有Element都继承自BuildContext这个抽象类。</p><h2><a aria-hidden="true" class="anchor" id="element"></a><a aria-hidden="true" class="hash-link" href="#element">#</a>Element</h2><p>表示Widget在树中特定位置的一个实例。因为widgets是不可变的，所以同一个widgets可以同时配置到多个子树。<!-- -->[Element]<!-- -->的配置表示了widget在树中的特定位置。父widget重新构建时会给该位置创建一个新的widget，与给定元素关联的widget就会更改。大多数元素都有一个惟一的子元素，但是有些widget(例如<!-- -->[RenderObjectElement]<!-- -->的子类)可以有多个子元素。</p><h2><a aria-hidden="true" class="anchor" id="renderobject"></a><a aria-hidden="true" class="hash-link" href="#renderobject">#</a>RenderObject</h2><p>表示在渲染树RenderTree上的节点对象。布局绘制工作都跟他有直接关系。</p><h2><a aria-hidden="true" class="anchor" id="window"></a><a aria-hidden="true" class="hash-link" href="#window">#</a>Window</h2><p>Window是Flutter Framework连接宿主操作系统的接口。这里看一下，有关Window的源码</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">class Window {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // 当前设备的DPI</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  double get devicePixelRatio =&gt; _devicePixelRatio;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // Flutter绘制区域的大小</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Size get physicalSize =&gt; _physicalSize;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // 当绘制区域大小改变回调</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  VoidCallback get onMetricsChanged =&gt; _onMetricsChanged;  </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // 绘制前回调，一般会受显示器的垂直同步信号VSync驱动，当屏幕刷新时就会被调用</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  FrameCallback get onBeginFrame =&gt; _onBeginFrame;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // 绘制回调  </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  VoidCallback get onDrawFrame =&gt; _onDrawFrame;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // 调度Frame，该方法执行后，onBeginFrame和onDrawFrame将紧接着会在合适时机被调用，</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // 此方法会直接调用Flutter engine的Window_scheduleFrame方法</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  void scheduleFrame() native &#x27;Window_scheduleFrame&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // 更新应用在GPU上的渲染,此方法会直接调用Flutter engine的Window_render方法</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  void render(Scene scene) native &#x27;Window_render&#x27;;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  // 发送平台消息</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  void sendPlatformMessage(String name,ByteData data,</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  PlatformMessageResponseCallback callback);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><h1><a aria-hidden="true" class="anchor" id="入口执行3步走"></a><a aria-hidden="true" class="hash-link" href="#入口执行3步走">#</a>入口执行3步走</h1><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">void runApp(Widget app) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  WidgetsFlutterBinding.ensureInitialized()</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    ..attachRootWidget(app)</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    ..scheduleWarmUpFrame();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>渲染widget并上载到屏幕上，框架给了我们这三步骤。</p><h5><a aria-hidden="true" class="anchor" id="第一步："></a><a aria-hidden="true" class="hash-link" href="#第一步：">#</a>第一步：</h5><p><code>WidgetsFlutterBinding.ensureInitialized()</code></p><p>WidgetsFlutterBinding初始化操作：这是一个单例模式，负责创建WidgetsFlutterBinding对象，这个对象继承抽象类BindingBase，并且附带7个mixin Binding，初始化渲染、语义化、绘制、平台消息以及手势等一系列操作；我理解这里就是做了全局调用的准备性工作，此时在还不会被触发。我们先看一下这个时序图，先有个整体概念。</p><p><img src="https://p5.ssl.qhimg.com/t01402aacf4a9c0b11a.png"/></p><p>1、把给定的widget渲染并贴到屏幕上去。
2、Widgets框架与应用程序绑定到一起的具体实现，就像胶水一样将framework与Flutter引擎关联在一起。
3、作为一个单例实现，也就是系统中只有这么一份。</p><p>我们一起看看Framework代码是如何处理的：</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">class WidgetsFlutterBinding extends BindingBase </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">                            with </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">                                 GestureBinding, </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">                                 ServicesBinding, </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">                                 SchedulerBinding, </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">                                 PaintingBinding, </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">                                 SemanticsBinding, </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">                                 RendererBinding, </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">                                 WidgetsBinding </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">{</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  static WidgetsBinding ensureInitialized() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    if (WidgetsBinding.instance == null)</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      WidgetsFlutterBinding();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    return WidgetsBinding.instance;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>此binding绑定到window上，代码内拿到的ui.window实例。</p><p>实例代码：<code>ui.Window get window =&gt; ui.window;</code></p><p>另外，我们继续跟进代码的过程中，发现在BindingBase有初始化，并且添加持久帧的回调PersistentFrameCallback，在应用程序的生命周期内，每一帧渲染都会调用它们。</p><h6><a aria-hidden="true" class="anchor" id="renderbinding"></a><a aria-hidden="true" class="hash-link" href="#renderbinding">#</a>RenderBinding</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">@protected</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  void drawFrame() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    pipelineOwner.flushLayout();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    pipelineOwner.flushCompositingBits();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    pipelineOwner.flushPaint();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    // 把bits发送到GPU</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    renderView.compositeFrame(); </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    // 同时把语义发送给操作系统</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    pipelineOwner.flushSemantics(); </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><h6><a aria-hidden="true" class="anchor" id="widgetbinding"></a><a aria-hidden="true" class="hash-link" href="#widgetbinding">#</a>WidgetBinding</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">@override</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  void drawFrame() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    try {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      if (renderViewElement != null)</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        buildOwner</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        .buildScope(renderViewElement);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      super.drawFrame();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      buildOwner.finalizeTree();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    } finally {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>最后代码跟踪到这个地方，我们看一下这段代码，所有压入render渲染管道的数据，都是经过这个方法生成每一帧的，在布局和画帧时会由Flutter引擎先调用handleDrawFrame，再调用这个方法。</p><h6><a aria-hidden="true" class="anchor" id="每一帧合成经历过什么？"></a><a aria-hidden="true" class="hash-link" href="#每一帧合成经历过什么？">#</a>每一帧合成经历过什么？</h6><h6><a aria-hidden="true" class="anchor" id="合成需要8个阶段："></a><a aria-hidden="true" class="hash-link" href="#合成需要8个阶段：">#</a>合成需要8个阶段：</h6><h6><a aria-hidden="true" class="anchor" id="1、动画阶段："></a><a aria-hidden="true" class="hash-link" href="#1、动画阶段：">#</a>1、动画阶段：</h6><p>在<!-- -->[Window.onBeginFrame]<!-- -->注册的<!-- -->[handleBeginFrame]<!-- -->方法，按顺序执行所有的临时帧回调<!-- -->[scheduleFrameCallback]<!-- -->。每一个动画都是由<!-- -->[Ticker]<!-- -->实例来驱动<!-- -->[AnimationController]<!-- -->执行。</p><h6><a aria-hidden="true" class="anchor" id="2、微任务："></a><a aria-hidden="true" class="hash-link" href="#2、微任务：">#</a>2、微任务：</h6><p>由临时帧回调调度的微任务，在方法<!-- -->[handleBeginFrame]<!-- -->执行返回后开始执行。 通常包括完成此帧的<!-- -->[Ticker]<!-- -->s和<!-- -->[AnimationController]<!-- -->s的回调。 注册到<!-- -->[Window.onDrawFrame]<!-- -->的方法，在<!-- -->[handleBeginFrame]<!-- -->, <!-- -->[handleDrawFrame]<!-- -->之后会调用持久性帧的回调方法。</p><h6><a aria-hidden="true" class="anchor" id="3、布局阶段："></a><a aria-hidden="true" class="hash-link" href="#3、布局阶段：">#</a>3、布局阶段：</h6><p>系统中所有的标记为dirty的<!-- -->[RenderObject]<!-- -->s，此时会安排妥当。</p><h6><a aria-hidden="true" class="anchor" id="4、合成bits阶段-："></a><a aria-hidden="true" class="hash-link" href="#4、合成bits阶段-：">#</a>4、合成bits阶段 ：</h6><p>这个阶段会在dirty <!-- -->[RenderObject]<!-- -->更新时进行。</p><p>5、绘制阶段 ：</p><p>系统中所有被标记为dirty 的<!-- -->[RenderObject]<!-- -->s都会被重新绘制。 标记方法调用<!-- -->[RenderObject.markNeedsPaint]<!-- -->。</p><h6><a aria-hidden="true" class="anchor" id="6、合成图层阶段："></a><a aria-hidden="true" class="hash-link" href="#6、合成图层阶段：">#</a>6、合成图层阶段：</h6><p>图层树被转换成<!-- -->[Scene]<!-- -->并发送给GPU。Scene对象是一个数据结构，保存最终渲染后的像素信息。</p><h6><a aria-hidden="true" class="anchor" id="7、语义阶段："></a><a aria-hidden="true" class="hash-link" href="#7、语义阶段：">#</a>7、语义阶段：</h6><p>在系统内所有被标记为脏的<!-- -->[RenderObject]<!-- -->s都更新了他们的语义。此时会生成语义节点树。可以参考<!-- -->[RenderObject.markNeedsSemanticsUpdate]<!-- -->详细标明一个语义的dirty对象</p><h6><a aria-hidden="true" class="anchor" id="8、最终阶段："></a><a aria-hidden="true" class="hash-link" href="#8、最终阶段：">#</a>8、最终阶段：</h6><p>在<!-- -->[drawFrame]<!-- -->方法返回以后<!-- -->[handleDrawFrame]<!-- -->会调用到前面初始化的时候通过<!-- -->[addPostFrameCallback]<!-- -->方法注册进来的post-frame回调。</p><h6><a aria-hidden="true" class="anchor" id="drawframe方法中调用到的方法释义："></a><a aria-hidden="true" class="hash-link" href="#drawframe方法中调用到的方法释义：">#</a>drawFrame方法中调用到的方法释义：</h6><h6><a aria-hidden="true" class="anchor" id="1、flushlayout："></a><a aria-hidden="true" class="hash-link" href="#1、flushlayout：">#</a>1、flushLayout：</h6><p>这是更新所有被标记为dirty的RenderObject对象的布局信息。 为了将对象呈现在屏幕新的位置上，此时布局信息绘制被清除掉。</p><p>2、flushComposittingBits：</p><p>这个方法在<!-- -->[flushLayout]<!-- -->之后与<!-- -->[flushPaint]<!-- -->之前调用，也就是渲染的第二关键步骤。它用来访问所有的子节点，判断是否需要组合，用<!-- -->[markNeedsPaint]<!-- -->方法来做标记哪些渲染对象发生了变化，最后完成所有需要组合的bits更新操作。 </p><h6><a aria-hidden="true" class="anchor" id="3、flushpaint："></a><a aria-hidden="true" class="hash-link" href="#3、flushpaint：">#</a>3、flushPaint：</h6><p>它是用来更新显示列表的所有渲染对象。绘制阶段发生在Layout之后和Scene被重新组合之前，Scene是由每个渲染对象的最新显示列表组成。 使用深度优先策略，按相反的顺序对脏节点排序。</p><h6><a aria-hidden="true" class="anchor" id="4、compositeframe："></a><a aria-hidden="true" class="hash-link" href="#4、compositeframe：">#</a>4、compositeFrame：</h6><p>首先它是renderView的方法
将所有组合好的布局树上载到引擎。也就是发送bits 到 GPU。
最后把呈现管道的输出出现在屏幕上。 这里调用了 window类的方法，<code>_window.render(scene);</code></p><h6><a aria-hidden="true" class="anchor" id="5、flushsemantics："></a><a aria-hidden="true" class="hash-link" href="#5、flushsemantics：">#</a>5、flushSemantics：</h6><p>把语义的变化发送到操作系统。</p><p>到此，第一步告一段落，用一副比较形象的图来表示Flutter布局渲染的整体流程：</p><p><img src="https://p3.ssl.qhimg.com/t01895e71701aa19a51.png"/></p><p>1、用户操作后触发更新运行动画，导致Widget State 的改变；
2、Widget State改变触发 Flutter framework 构建新的Widget树；
3、Framework根据新与旧 Widget树的差异更新Render树，从新排版界面布局；
4、新的Render树合成输出新的图层树，最后发送给到GPU显示到屏幕上；</p><h5><a aria-hidden="true" class="anchor" id="第二步："></a><a aria-hidden="true" class="hash-link" href="#第二步：">#</a>第二步：</h5><p><code>..attachRootWidget(app)</code></p><p>进行级联调用attachRootWidget，遍历挂载整个视图树，并建立Widget、Element、RenderObject之间的连接与关系，此处Element的具体类型为RenderObjectToWidgetElement；我们先看一下这个时序图，先有个整体概念。<img src="https://p5.ssl.qhimg.com/t017d3101d2aa744ef5.png"/></p><p>首先我们来看一下下面的这些方法：
1、attachRootWidget(app)，将获取到的widget 附加到 <!-- -->[renderViewElement]<!-- -->上，必要的时候才会去创建它。这个方法只有在<!-- -->[runApp]<!-- -->方法配置widget树时调用它。
2、RenderObjectToWidgetAdapter就是一个桥接，Widget与RenderObject之间的一个桥接类。
3、RenderObjectToWidgetAdatper这个桥接类与RenderObjectToWidgetElement涉及到几个方法分别是：attachToRenderTree、</p><p>createElement、</p><p>mount、</p><p>rebuild、</p><p>updateChild，</p><p>inflateWidget，</p><p>就是将创建出来的元素element关联到render树上，将widget、element、RenderObject建立关系。当然这里面涉及到一些构建更新渲染到策略，后面由涉及到。</p><h6><a aria-hidden="true" class="anchor" id="attachtorendertree"></a><a aria-hidden="true" class="hash-link" href="#attachtorendertree">#</a>attachToRenderTree</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">void attachRootWidget(Widget rootWidget) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    container: renderView,</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    debugShortDescription: &#x27;[root]&#x27;,</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    child: rootWidget</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  ).attachToRenderTree(buildOwner, renderViewElement);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>这是attachRootWidget方法，也就是上图到第一步。 由<!-- -->[runApp]<!-- -->调用将配置好的widget树关联到<!-- -->[renderViewElement]<!-- -->上。</p><h6><a aria-hidden="true" class="anchor" id="attachtorendertree-1"></a><a aria-hidden="true" class="hash-link" href="#attachtorendertree-1">#</a>attachToRenderTree</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  [RenderObjectToWidgetElement&lt;T&gt; element]) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    if (element == null) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      owner.lockState(() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        element = createElement();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        assert(element != null);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        element.assignOwner(owner);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      });</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      owner.buildScope(element, () {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        element.mount(null, null);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      });</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    } else {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      element._newWidget = this;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      element.markNeedsBuild();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    return element;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>这里attachToRenderTree方法，主要是用于<!-- -->[runApp]<!-- -->加载应用程序，根据不同策略创建更新构建Widget、Element、RenderObject的对应关系。如果“element”为空，这个函数将创建一个新元素。否则，给定的元素Element更新对应关系到这个Widget。</p><p>下面我们一起看看每个方法的简单逻辑</p><h6><a aria-hidden="true" class="anchor" id="createelement"></a><a aria-hidden="true" class="hash-link" href="#createelement">#</a>createElement</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">@override</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">RenderObjectToWidgetElement&lt;T&gt; createElement() =&gt; RenderObjectToWidgetElement&lt;T&gt;(this);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">class RenderObjectToWidgetElement&lt;T extends RenderObject&gt; </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">extends RootRenderObjectElement {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  ///创建基于[RenderObject]托管的Element</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  RenderObjectToWidgetElement(RenderObjectToWidgetAdapter&lt;T&gt; widget) </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  : super(widget);</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>创建基于<!-- -->[RenderObject]<!-- -->托管的Element</p><h6><a aria-hidden="true" class="anchor" id="mount"></a><a aria-hidden="true" class="hash-link" href="#mount">#</a>mount</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">@override</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  void mount(Element parent, dynamic newSlot) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    assert(parent == null);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    super.mount(parent, newSlot);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    _rebuild();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>mount过程就是将element挂载到父类到槽上去。</p><h6><a aria-hidden="true" class="anchor" id="_rebuild"></a><a aria-hidden="true" class="hash-link" href="#_rebuild">#</a>_rebuild</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-undefined codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">void _rebuild() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    try {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      _child = updateChild(_child, widget.child, _rootChildSlot);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    } catch (exception, stack) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      final Widget error = ErrorWidget.builder(details);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      _child = updateChild(null, error, _rootChildSlot);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>_rebuild的过程，调用update进行了child节点的更新操作。</p><h6><a aria-hidden="true" class="anchor" id="updatechild"></a><a aria-hidden="true" class="hash-link" href="#updatechild">#</a>updateChild</h6><p>这个方法就不贴代码了，对child节点进行更新的策略如下图：</p><p><img src="https://p0.ssl.qhimg.com/t0123993c0bd88b7dcb.png"/></p><p>判断是否更新child在代码里面，就是查看当前child是否相符，也就是键值Key与运行时runtimeType是否完全一样，是的话就认为是一个类型型号的child节点。稍后会说到这一块的更新策略在Framework中怎么落地的。</p><h6><a aria-hidden="true" class="anchor" id="inflatewidget"></a><a aria-hidden="true" class="hash-link" href="#inflatewidget">#</a>inflateWidget</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">@protected</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  Element inflateWidget(Widget newWidget, dynamic newSlot) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    final Key key = newWidget.key;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    if (key is GlobalKey) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      final Element newChild = _retakeInactiveElement(key, newWidget);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      if (newChild != null) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        newChild._activateWithParent(this, newSlot);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        final Element updatedChild = updateChild(newChild, newWidget, newSlot);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        return updatedChild;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    final Element newChild = newWidget.createElement();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    newChild.mount(this, newSlot);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    return newChild;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>看到inflateWidget方法，在GlobalKey中查找newWidget的Key，查看是否有可以复用到Element，然后就可以更新可复用的Element。当然如果有没有找到的话，就需要创建新的Element啦。</p><p>经过上面流程的分析用下图总结流程流转过程：</p><p><img src="https://p4.ssl.qhimg.com/t013a3d006ac22b3240.png"/></p><p>Widget部分：存放渲染内容、视图布局信息。
Element部分：存放上下文，通过Element遍历视图树，Element同时持有Widget和RenderObject。
RenderObject部分：根据Widget的布局属性进行Layout，Paint， Widget传入的内容构建Layer树。</p><h5><a aria-hidden="true" class="anchor" id="第三步："></a><a aria-hidden="true" class="hash-link" href="#第三步：">#</a>第三步：</h5><p><code>..scheduleWarmUpFrame();</code></p><p>再次进行级联调用scheduleWarmUpFrame，这里用来调度预热帧，执行帧绘制方法handleBeginFrame和handleDrawFrame。此时会触发布局渲染工作。</p><p>这里面有一个有意思的点就是当再次调用<!-- -->[runApp]<!-- -->这个方法，会用新的widget替换屏幕上之前的旧的widget。工作机理是新旧widget树比对，将差异点应用于底层呈现树。举个直接的例子，就类似于我们写的计数器的demo，<!-- -->[StatefulWidget]<!-- -->在调用<!-- -->[State.setState]<!-- -->后重新构建<!-- -->[State.setState]<!-- -->时所发生的变化。</p><p><img src="https://p0.ssl.qhimg.com/t013a7edb98c69f18f1.png"/></p><p>这里方法调用就比较简单了，涉及到的方法少，但是做的事情非常重要。我们先简单看一下几个方法：
1、scheduleWarmUpFrame，执行热身帧，在SchedulerBinding内执行的方法
2、handleBeginFrame准备执行帧绘制
3、handleDrawFrame引擎调用准备出来一个新的帧
4、scheduleFrame在适当的时机，请求调用window类的<!-- -->[onBeginFrame]<!-- -->和<!-- -->[onDrawFrame]<!-- -->回调。</p><p>我们一起看一下这里的代码</p><h6><a aria-hidden="true" class="anchor" id="schedulewarmupframe"></a><a aria-hidden="true" class="hash-link" href="#schedulewarmupframe">#</a>scheduleWarmUpFrame</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">void scheduleWarmUpFrame() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    ///使用定时器确认微任务执行刷新</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    Timer.run(() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      // 使用定时器准备执行帧绘制</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      handleBeginFrame(null);</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    });</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    Timer.run(() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      handleDrawFrame();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      //重置时间戳，避免帧跳跃</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      resetEpoch();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      _warmUpFrame = false;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      if (hadScheduledFrame)</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        scheduleFrame();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    });</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    // 事件锁定，</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    // 保证在执行期间不会有其他任务穿插入进来</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    lockEvents(() async {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      await endOfFrame;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      Timeline.finishSync();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    });</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>这个方法在响应到系统Vsync信号前，尽可能快的去执行一帧绘制。
先简单看一下第一个方法内代码执行的具体方法，这里有注释，可以简单看一下。</p><h6><a aria-hidden="true" class="anchor" id="scheduleframe"></a><a aria-hidden="true" class="hash-link" href="#scheduleframe">#</a>scheduleFrame</h6><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">void scheduleFrame() {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    if (_hasScheduledFrame </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">         || !_framesEnabled)</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      return;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    ..........</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    window.scheduleFrame();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    _hasScheduledFrame = true;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">  }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">在适当的时机，请求[onBeginFrame]和[onDrawFrame]回调。</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">void scheduleFrame() native &#x27;Window_scheduleFrame&#x27;;</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>方法<!-- -->[scheduleFrame]<!-- -->，需要注意的是：</p><p>1、在设备屏幕关闭时，调用可能会延迟；</p><p>2、当屏幕再次打开并且应用程序可见时，才会被调用。</p><p>还有特别有意思的是，在当前帧未完成情况下，如果我们调用此函数，就会强制调度到另一个帧。在通常情况下，调度帧是由操作系统发出的“Vsync”信号来触发。</p><p>在看代码的时候，还有看到过另外相关一个方法，在这里做个对比：</p><p>1、<!-- -->[scheduleForcedFrame]<!-- -->, 忽略<!-- -->[lifecycleState]<!-- -->强制执行一帧；
2、<!-- -->[scheduleWarmUpFrame]<!-- -->，忽略&quot;Vsync&quot;信号立即尽可能早的执行一帧；</p><h1><a aria-hidden="true" class="anchor" id="一些思考"></a><a aria-hidden="true" class="hash-link" href="#一些思考">#</a>一些思考</h1><h3><a aria-hidden="true" class="anchor" id="1、widget-变化对布局的影响"></a><a aria-hidden="true" class="hash-link" href="#1、widget-变化对布局的影响">#</a>1、Widget 变化对布局的影响</h3><h5><a aria-hidden="true" class="anchor" id="widget-变化对布局的影响（情形一）"></a><a aria-hidden="true" class="hash-link" href="#widget-变化对布局的影响（情形一）">#</a>Widget 变化对布局的影响（情形一）</h5><p><img src="https://p5.ssl.qhimg.com/t017ed2d9a9788d65d0.png"/></p><p><img src="https://p1.ssl.qhimg.com/t01b00cbb8751ccdb50.png"/></p><p>第一次完成布局后，看到是对应关系如上虚线部分。当黄色矩形发生颜色变化时，它并没有新建 Element，而是复用了之前矩形 的 Element，由于矩形并没有改变 Widget 类型，所以 Element 只需要根据新的 Widget 修改自身的颜色配置参数作为新的 Widget 距可以了。正是通过这种可变与不可变对象的组合，使得Flutter布局模式灵活而又高效。</p><h5><a aria-hidden="true" class="anchor" id="widget-变化对布局的影响（情形二）"></a><a aria-hidden="true" class="hash-link" href="#widget-变化对布局的影响（情形二）">#</a>Widget 变化对布局的影响（情形二）</h5><p><img src="https://p4.ssl.qhimg.com/t015d717353e1ba68cd.png"/></p><p>情形二中，子圆形蓝色 Widget变为了 三角形红色，此时 Flutter 的布局重建会有怎样的变化呢？</p><p><img src="https://p2.ssl.qhimg.com/t01fe0248d31133704a.png"/></p><p>因为矩形 Widget 类型没变化，所以并没有引起 Element 与 Render Object 的实际变化。Element 照常持有了新矩形绿色 Widget 与 矩形RenderObject的引用。</p><p><img src="https://p3.ssl.qhimg.com/t01a21c20bf45202528.png"/></p><p>三角形红色Widget类型发生了变化，就不可以复用 由 矩形绿色 类型创建的 Element 与 RenderObject，那怎么办呢？</p><p><img src="https://p3.ssl.qhimg.com/t01e9bd142b42b341e5.png"/>
此时，Framework 就会更新Widget、Element 与 RenderObject到关系，暂时分离相互之间的关系。我们在前面分析代码时候，看到他们在创建之前是在缓存里面查一下看有没有存在，所以这缓存策略也是优化性能的策略之一。</p><p><img src="https://p0.ssl.qhimg.com/t01e1316ae4d0e8294f.png"/></p><p>最后，三角形红色Widget 重新调用 createElement() 与 createRenderObject()方法进行构建，再次mount挂载到父节点的 slot 槽上。新的 Element 就与三角形 Widget 和三角形 RenderObject建立了关系。</p><p>通过上面到两个情形，我们发现了布局变化在framework层处理逻辑是不一样的。感兴趣的同学可以再看看源代码。</p><h3><a aria-hidden="true" class="anchor" id="2、重布局导致性能影响"></a><a aria-hidden="true" class="hash-link" href="#2、重布局导致性能影响">#</a>2、重布局导致性能影响</h3><p>为避免某一渲染对象重布局时触发父级对象的重布局，减少不必要的性能开销，Flutter 框架给出了布局边界控制机制。即通过在某一渲染对象上设置重布局边界，避免重布局的影响范围扩散出去，那满足哪些条件，会自动设置重布局边界呢？</p><p>我们一起看看下面的代码</p><pre class="mdxCodeBlock_iHAB0Zg7"><div class="codeBlockWrapper_2QGZbNRm"><pre class="prism-code language-dart codeBlock_19pQyIiL" style="color:#d6deeb;background-color:#011627"><div class="token-line" style="color:#d6deeb"><span class="token plain">void layout(Constraints constraints, </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">           { bool parentUsesSize = false }) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    RenderObject relayoutBoundary;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    if (!parentUsesSize || sizedByParent </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">       || constraints.isTight </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">       || parent is! RenderObject) </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      relayoutBoundary = this;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    } else {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      final RenderObject parent = this.parent;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      relayoutBoundary = parent._relayoutBoundary;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    if (!_needsLayout </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    &amp;&amp; constraints == _constraints </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    &amp;&amp; relayoutBoundary==_relayoutBoundary) </span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      return;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    _constraints = constraints;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    _relayoutBoundary = relayoutBoundary;</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    if (sizedByParent) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      try {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">        performResize();</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      } catch (e, stack) {</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">      }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    }</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain">    。。。。。。。。。。</span></div><div class="token-line" style="color:#d6deeb"><span class="token plain"> }</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1BYjXM7E">Copy</button></div></pre><p>看到满足边界判断的地方，就直接返回不再去调用执行。总结如下：
1、parentUsesSize 为false， 父对象大小与子对象大小无任何依赖的情况。
2、sizedByParent 为 true，子对象大小受父对象约束。
3、constraints.isTight 父对象对子对象的大小有严格限定。</p><p>下面我们看一下比较形象标识其中一个条件的图：</p><p><img src="https://p3.ssl.qhimg.com/t018365849f5ed381b1.png"/></p><p>如图满足constraints.isTight 父对象对子孩子的大小有严格限定，红色的弧线部分，此时子对象自动被设置隔离带布局边界，子树的重布局不会扩散到父级。可以说这也是提高性能的好办法。</p><h1><a aria-hidden="true" class="anchor" id="一些问题"></a><a aria-hidden="true" class="hash-link" href="#一些问题">#</a>一些问题</h1><p>在总结的过程中，朋友们也提出了比较好的问题，这里列举一下：</p><h5><a aria-hidden="true" class="anchor" id="1、第三步schedulewarmupframe可以不调用吗？"></a><a aria-hidden="true" class="hash-link" href="#1、第三步schedulewarmupframe可以不调用吗？">#</a>1、第三步scheduleWarmUpFrame()可以不调用吗？</h5><p>这个方法的作用是，在系统Vsync信号到来之前尽可能快的执行。这个方法最好是在应用程序启动的时候调用的，目的是让第一帧尽可能多的运行几毫秒。如果不调用这个方法，App倒是也可以启动运行，只是界面布局之初可能有那么几毫秒不会进行布局渲染工作，直到系统Vsync信号到来。</p><h6><a aria-hidden="true" class="anchor" id="2、widget、element、renderobject-三者对应树关系，为什么有中间这一层element，而不是widget直接对应renderobject呢？"></a><a aria-hidden="true" class="hash-link" href="#2、widget、element、renderobject-三者对应树关系，为什么有中间这一层element，而不是widget直接对应renderobject呢？">#</a>2、Widget、Element、RenderObject 三者对应树关系，为什么有中间这一层Element，而不是widget直接对应RenderObject呢？</h6><p>开始看这部分的时候，其实我觉得好奇怪，怎么中间还多了一层Element，这是什么操作呀，在了解到框架设计者的思想后，明白了些许原因。查了一些资料了解到浏览器方面的的技术“虚拟DOM”。它是为解决渲染性能问题而生的，在DOM操作时性能损耗与局部DOM操作更新有一定麻烦，假如对网页上个别标签进行更新，如果此时直接操作整个DOM，那开销是很大的。这个时候就需要有个优化的办法，汇总各个元素的更新情况，通过“diff算法”计算出与原来 DOM 树的差异，最后通过一次 DOM 更新解决，这样的设计使得性能大大提高。在Flutter Framework层对当前需要rebuild的Element都会进行标记为dirty状态，即<!-- -->[markNeedsBuild]<!-- -->方法，这时候可以这么理解 Element 树就是用来发挥“虚拟DOM”的作用，使得视图更高效地完成构建。Element由 Widget 的“配置描述信息”构建出来的结构化组件，里面包含了各种部件的上下文信息。</p></article><div class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/flutter">flutter</a><a class="margin-horiz--sm" href="/blog/tags/widget">widget</a></div><div class="col text--right"></div></div></div><div class="margin-vert--xl"><nav class="pagination-nav"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2019/08/14/flutter-platform-channel"><h5 class="pagination-nav__link--sublabel">Previous Post</h5><h4 class="pagination-nav__link--label">« <!-- -->Flutter Platform Channel 使用与源码分析</h4></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2019/08/09/flutter-platform-view"><h5 class="pagination-nav__link--sublabel">Next Post</h5><h4 class="pagination-nav__link--label">Flutter Platform View 使用及原理简析<!-- --> »</h4></a></div></nav></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="text--center">Copyright © 2019 Flutter-Fans. Built with Docusaurus.</div></div></footer>
</div>

<script type="text/javascript" src="/runtime~main.a812c55c962abd52891e.js"></script>

<script type="text/javascript" src="/main.c96f282b900a0b52042c.js"></script>

<script type="text/javascript" src="/vendors.7d2d565e7d925589e9f2.js"></script>

<script type="text/javascript" src="/react-helmet.8e7fdfe7a549fe294bcd.js"></script>

<script type="text/javascript" src="/prism-react-renderer.c8da09aeb9119d2dd62f.js"></script>

<script type="text/javascript" src="/component---users-zhaoyan-documents-project-fluttercn-dev-src-pages-index-js-85-a-818.4945fdd399e2e4cd3638.js"></script>

<script type="text/javascript" src="/docusaurus.c6059712e04a5824f5a6.js"></script>

<script type="text/javascript" src="/content---blog-2019-08-11-flutter-rendercc-3-7dd.9c618974b67616ee0108.js"></script>

<script type="text/javascript" src="/nextItem---blog-2019-08-14-flutter-platform-channel-72-f-689.36393d7d44adf2a27924.js"></script>

<script type="text/javascript" src="/metadata---blog-2019-08-14-flutter-platform-channel-8-ef-2e2.48be2e8936c6bae9c063.js"></script>

<script type="text/javascript" src="/nextItem---blog-2019-08-11-flutter-render-1-b-0-118.a67d4c5a2d14092242f7.js"></script>

</body>
</html>